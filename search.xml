<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis 学习总结]]></title>
    <url>%2F2019%2F01%2F30%2FRedis-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[NoSQL 是什么？NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。 NoSQL 数据库四大分类 KV键值：Redis 文档型数据库(bson格式比较多)：MongoDB 列存储数据库：HBase、 图关系数据库：Neo4J、 InfoGrid 四者对比： 分布式数据库中CAP原理CAP+BASE1.CAPC: Consistency（强一致性） A: Availability（可用性） P: Partition tolerance（分区容错性） CAP理论的核心：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 2. BASEBASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。 BASE其实是下面三个术语的缩写： 基本可用（Basically Available） 软状态（Soft state） 最终一致（Eventually consistent） 它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法 Redis 是什么？Redis（REmote DIctionary Server(远程字典服务器)）：是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的(key/value)分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库，是当前最热门的NoSql数据库之一,也被人们称为数据结构服务器。 Redis 官网：https://redis.io Redis 能干嘛？ Redis被广泛应用于缓存方向， 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 为什么要使用Redis（为什么要使用缓存）？1. 高性能在不做缓存的情况下，用户发送请求访问数据库中数据，此过程是非常慢的，因为这些数据要从硬盘读取。而将用户访问的数据存放于缓存中，下一次访问这些数据可以直接从缓存中获取。而操作缓存就是直接操作内存，速度是非常快的。当数据库中数据改变之后，同步更新缓存中数据即可。 2. 高并发直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以可以考虑把数据库中的部分数据（热点数据）转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库，大大提高系统并发。 Redis 与 Memcached 的区别（面试可能会问到） Redis 支持丰富的数据类型；Memcached 支持简单数据类型Stirng Redis 支持数据持久化；Memcached 不支持数据持久化 Redis 原生支持cluster 模式； Memcached 需要依赖客户端实现往集群中写入分片数据 Redis 使用单进程的多路IO复用模型；Memcached使用多线程非阻塞IO复用模型 Redis 数据类型及使用场景分析1. String 常用命令: set,get,decr,incr,mget 等。 String类型是简单的 key-value 类型；String类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。一个redis中字符串value最多可以是512M。 应用：常规key-value缓存应用； 常规计数：微博数，粉丝数等。 2. Hash 常用命令： hget,hset,hgetall 等。 Redis hash 是一个键值对集合。Redis hash是一个string类型的field和value的映射表，特别适合用于存储对象。 应用：存储用户信息，商品信息等等 3. List 常用命令: lpush,rpush,lpop,rpop,lrange等 Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个双向链表。另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询 ，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。 应用：微博的关注列表，粉丝列表，消息列表等 4. Set 常用命令： sadd,spop,smembers,sunion 等 set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。 应用：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下： 1sinterstore key1 key2 key3 将交集存在key1内 5. Zset(sorted set：有序集合) 常用命令： zadd,zrange,zrem,zcard等 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 应用： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。 更多Redis 常用命令：http://redisdoc.com/ Redis 配置文件redis.conf解析http://download.redis.io/redis-stable/redis.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273参数说明redis.conf 配置项说明如下：1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字 port 63794. 绑定的主机地址 bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 save &lt;seconds&gt; &lt;changes&gt; Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb dbfilename dump.rdb12. 指定本地数据库存放目录 dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码 masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭 requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息 maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendonly no19. 指定更新日志文件名，默认为appendonly.aof appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值： no：表示等操作系统进行数据缓存同步到磁盘（快） always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） everysec：表示每秒同步一次（折衷，默认值） appendfsync everysec 21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制） vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 hash-max-zipmap-entries 64 hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍） activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 include /path/to/local.conf Redis 持久化机制如何保证 Redis 挂掉之后在重启数据可以恢复？？？ Redis 支持两种数据持久化方式：快照（Snapshotting ，RDB）和 追加文件（Append Only File，AOF） 1. RDB是什么？在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 怎么做？Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 Fork：Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程 如何配置？快照持久化是Redis默认采用的持久化方式（dump.rdb），在redis.conf配置文件中默认有此下配置： 123save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 如何创建？ 配置文件中默认的快快照配置（save选项） 使用 save 命令：save时只管保存，其它不管，全部阻塞 使用 bgsave 命令：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间 执行 flashall 命令：执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义 如何恢复？将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可 123127.0.0.1:6379&gt; config get dir1) &quot;dir&quot;2) &quot;/myredis&quot; 优劣势？ 优势：适合大规模的数据恢复；对数据完整性和一致性要求不高 劣势：在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改；Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑]]></content>
      <categories>
        <category>Redis</category>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息队列总结]]></title>
    <url>%2F2019%2F01%2F26%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[消息队列和消息 “消息队列”(Message queue)是在消息的传输过程中保存消息的容器。“消息” 是在两台计算机间传送的数据单位。消息可以非常简单，例如只包含文本字符串；也可以更复杂，可能包含嵌入对象。 消息队列又称消息中间件（区别于本地消息队列，本地消息队列指的是JVM内的队列实现） ，是一种独立的队列系统，消息中间件经常用来解决内部服务之间的 异步调用问题 常见的消息队列当前使用较多的消息队列有RabbitMQ、ActiveMQ、RocketMQ、Kafka等等，当然redis数据库也可以实现消息队列，不过不推荐，redis本身设计就不是用来做消息队列的。 消息队列使用场景 异步调用： ​ 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。 解耦 ： 一个业务的非核心流程需要依赖其他系统，但结果并不重要，有通知即可。 分布式系统模块之间耦合的两种方式：分布式消息队列 和 分布式服务 分布式服务： SOA（Service Oriented Architecture面向服务体系结构 ） Dubbo 等分布式服务框架 分布式消息队列：事件驱动架构（生产者—消费者 发布—订阅） ​ 消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。 ​ 另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。 最终一致性 ： 指的是两个系统的状态保持一致，可以有一定的延迟，只要最终达到一致性即可。经常用在解决分布式事务上。 广播 ： 消息队列最基本的功能。生产者只负责生产消息，订阅者接收消息。 错峰和流控 ​ 消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 （秒杀、抢购、抢票等） 消息队列两个重要概念 消息代理（Message Broker） 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。 目的地（Destination） 队列（queue）：点对点消息通信（point-to-point） 消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列 消息只有唯一的发送者和接受者，但并不是说只能有一个接收者 主题（topic）：发布（publish）/订阅（subscribe）消息通信 发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息 常见消息队列介绍 ActiveMQ： ActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ是一个完全支持JMS1.1和J2EE 1.4规范的JMSProvider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。 官网：http://activemq.apache.org/ 具体可以参考： 《消息队列ActiveMQ的使用详解》 RabbitMQ: RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗 AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。 官网：http://www.rabbitmq.com/ 具体可以参考： 《消息队列之 RabbitMQ》 RocketMQ：RocketMQ是阿里开源的消息中间件，目前在Apache孵化，使用纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景，支撑了阿里多次双十一活动。 官网：http://rocketmq.apache.org/ 具体可以参考： 《RocketMQ 实战之快速入门》 《十分钟入门RocketMQ》 （阿里中间件团队博客） Kafka：Kafka是一个分布式的、可分区的、可复制的、基于发布/订阅的消息系统（现在官方的描述是“一个分布式流平台”），由Scala和Java编写 ，Kafka主要用于大数据领域，当然在分布式系统中也有应用。目前市面上流行的消息队列RocketMQ就是阿里借鉴Kafka的原理、用Java开发而得。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。 官网：http://kafka.apache.org/ 具体可以参考： 《Kafka应用场景》 《初谈Kafka》 总结： ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。 RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。 RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的 kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。 参考：《Java工程师面试突击第1季-中华石杉老师》 性能对比：《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》 最后：文章参考： 消息队列深入解析 数据通信(RESTful、RPC、消息队列)相关知识点总结.md) 消息队列总结：新手也能看懂，消息队列其实很简单 感谢原作者：SnailClimb]]></content>
      <categories>
        <category>Java</category>
        <category>架构</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能远程服务调用框架-Dubbo]]></title>
    <url>%2F2019%2F01%2F26%2F%E9%AB%98%E6%80%A7%E8%83%BD%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%A1%86%E6%9E%B6-Dubbo%2F</url>
    <content type="text"><![CDATA[何为RPC？RPC（Remote Procedure Call）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发分布式程序就像开发本地程序一样简单。 RPC采用客户端（服务调用方）/服务器端（服务提供方）模式， 都运行在自己的JVM中。客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。RPC主要依赖的技术包括序列化、反序列化和数据传输协议，这是一种定义与实现相分离的设计。 目前Java使用比较多的RPC方案主要有RMI（JDK自带）、Hessian、Dubbo以及Thrift等。 注意： RPC主要指内部服务之间的调用，RESTful也可以用于内部服务之间的调用，但其主要用途还在于外部系统提供服务，因此没有将其包含在本知识点内。 Http 与 RPC？良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。 何为Dubbo?Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 上述节点简单说明： Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 如何使用Dubbo？Dubbo 官方文档中文版 Dubbo 官网 Dubbo Github 注册中心注册中心用来注册服务和进行负载均衡，哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是IP地址和服务名称的对应关系。 dubbo官方提供了几种实现注册中心的方式： Multicast 注册中心 Zookeeper 注册中心 Redis 注册中心 Simple 注册中心 注意：另外官方明确推荐使用Zookeeper 注册中心的方式。]]></content>
      <categories>
        <category>Java</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能 MySQL]]></title>
    <url>%2F2019%2F01%2F06%2F%E9%AB%98%E6%80%A7%E8%83%BDMySQL%2F</url>
    <content type="text"><![CDATA[1. MySQL 数据库逻辑架构图 每个虚线框为一层，总共三层。 第一层，服务层(为客户端服务):为请求做连接处理，授权认证，安全等。 第二层，核心层:查询解析，分析，优化，缓存，提供内建函数;存储过程，触发器，视图。 第三层，存储引擎层，不光做存储和提取数据，而且针对特殊数据引擎还要做事务处理。 2. 事务ACID特性原子性：（atomicity） 一致性：（consistency） 隔离性：（isolation） 持久性：（durability） 3. 隔离级别ASNI SQL 隔离级别 隔离级别 脏读可能性 不可重复读可能性 幻读可能性 加锁读 read uncommitted（未提交读） yes yes yes no read committed（提交读） no yes yes no repeatable read（可重复读） no no yes no serializable（可串行化） no no no no 注意：事务隔离级别越低通常可执行更高的并发 4. MySQL 中存储引擎1. 事务存储引擎 InnoDB NDB Cluster 第三方： XtraDB 、PBXT 等 注意： MySQL 默认开启 AUTOCOMMIT，若不显示开启一个事务，则每个查询被当作一个事务执行提交操作 1234567mysql&gt; show variables like &apos;autocommit&apos;;+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit | ON |+---------------+-------+1 row in set (0.52 sec) 查询表相关信息： 每个表对应一个 .frm 文件 12345678910111213141516171819202122mysql&gt; show table status like &apos;user&apos; \G;*************************** 1. row *************************** Name: user Engine: InnoDB Version: 10 Row_format: Dynamic Rows: 7 Avg_row_length: 2340 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: NULL Create_time: 2018-07-07 16:32:53 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: 1 row in set (0.00 sec) 2. MySQL 中主要存储引擎 InnoDB：采用MVCC （多版本并发控制）支持高并发，基于聚簇索引建立，事务型存储引擎 MyISAM：MySQL 5.1 及以前版本默认使用，不支持事务和行级锁，不支持崩溃后安全恢复 MySQL内建其他存储引擎 Archive 引擎： 只支持 INSERT 和 SELECT 操作，5.1 之前不支持索引，可实现高并发插入， 适合 日志和数据采集类应用，或某些需要快速INSERT才注意的场合 Blackhole引擎:没有实现任何存储机制，适用于复制架构和日志审核 CSV引擎： 可以将普通CSV文件作为MySQL的表来处理，可做为一种数据交换机制 Federated引擎： 联合引擎，访问MySQL服务器的一个代理 Memory引擎： 数据保存在内存中，速度非常快，重启数据丢失，支持hash索引 Merge引擎： MyISAM引擎的一个变种，用于日志和数据仓库类应用 NDB集群引擎： SQL 和 NDB 原生协议之间的接口 第三方存储引擎 OLTP 类引擎： XtraDB 、 PBXT、 TokuDB（一种大数据存储引擎）、RethinkDB Falcon存储引擎 面向列的存储引擎： MySQL默认面向行，但大数据量处理，面向列效率会更高。 例如 Infobright，应用于数据分许和数据仓库，数据高度压缩，不支持索引 InfiniDB，可在一组机器集群间做分布式查询 社区存储引擎 5. Schema 与 数据类型优化 整数类型两种类型的数字：整数（whole number）和实数（real number） 若要存储整数：tinyint、smallin 、 mediumint、int、bigint 分别使用 8 16 24 32 64 位存储空间 unsigned 属性表示不允许负值，使正数的上限提升了一倍 注意： 能选择的都是存储类型，计算时会使用64位 bigint计算 实数类型带有小数部分的数字。 flout、double 支持使用标准浮点运算进行近似运算 decimal 用于存储精确小数，支持精确计算（5.0 之后MySQL 自身实现） 可指定小数点前后所允许的最大位数 注意： 计算时，MySQL 使用double进行计算 字符串类型varchar 与 char， 在磁盘和内存中的存储形式主要更存储引擎有关 varchar ：变长字符串，需要额外使用 1 个或 2 个字节（列最大长度大于255字节） 来记录字符串的长度，但由于变成，在进行UPDATE操作是易造成碎片 char：定长字符串，适用于存放短字符串，且MySQL会删除字符串末尾空格 注意： char 、varchar 是以字符为单位 binary varbinary 存储二进制字符串，存储的是字节码，使用 ‘\0’ 进行填充 blob：二进制方式存取很大数据 tinyblob、smallblob、（blob）、mediumblob、longblob、 text：字符当时存取很大数据 tinytext、smalltext、（text）、mediumtext、longtext 日期和时间类型 datatime：能保存大范围的值，精度为s，把日期和时间封装到格式为YYYYMMDDHHMMSS 的整数中，使用 8 个字节的存储空间。例如 ”2019-01-06 19:41:25“ timestamp：保存了从1970-01-01午夜到现在的秒数，使用4个字节的存储空间（1970-2048） 其值与时区有关 位数据类型 bit：5.0 之前是tinyint 的同义词，5.0之后为一个新数据类型 MySQL 将其当作字符串类型，而非数字类型 set：MySQL内部是以一系列打包的为的集合来表示 6. 加快 ALTER TABLE 操作速度MySQL 执行大部分修改表结构的操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入到 新表中，然后删除旧表。 例如： 12mysql&gt; alter table sakila.film -&gt; modify column rental_duration tinyint(3) not null default 5; 而实际上，MySQL ALTER TABLE操作允许使用 ALTER COLUMN 、MODIFY COLUMN、CHANGE COLUMN语句 修改列，则上述SQL 语句可以修改为 12mysql&gt; alter table sakila.film -&gt; alter column rental_duration set default 5; 此语句会直接修改 .frm 文件而不涉及表数据 7. 创建高性能索引索引在MySQL 中也叫做 “键（key）”， 是存储引擎用于快速找到记录的一种数据结构 注意：索引是在存储引擎层，而非服务器层，不同存储引擎索引工作方式并不相同 1. 索引的类型 B-Tree 索引 若不特别指明类型，一般所说的索引都是B-Tree索引，使用B-Tree 数据结构进行存储， 但不同存储引擎也可能使用不同的存储结构。适用于 全键值、键值范围和键值前缀查找 哈希索引 基于哈希表实现，只有精确匹配索引所有的列的查询才有效，每一列对应一个不同的哈希码， 哈希索引将所有的哈希码存储在哈希索引中，同时在哈希表中保存执行每个数据行的指针。 注意： 只有Memory 引擎显式支持哈希索引，且支持非唯一哈希索引 InnoDB引擎可以在B-Tree索引基础上自动创建“自适应哈希索引” 空间数据索引（R-Tree） MyISAM 表支持空间索引，可以用作地理数据存储。空间索引会从所有维度来索引数据 全文索引 查找的是文本中的关键字，而非直接比较索引中的值。全文索引适用于 MATCH AGAIINST 操作，而不是普通的WHERE条件查询 其他索引类别 TokuDB 的 形树索引、ScaleDB的Patricia tries等 2. 索引的优点 大大减少了服务器需要扫描的数据量 帮助服务器避免排序和临时表 将随机IO变为顺序IO 8. MySQL 高级特性 MySQL 从 5.0 到 5.1 版本开始引入了很多新特性，例如分区、触发器等。 分区表对于用户而言，分区表是一个独立的逻辑表，但底层由多个物理子表组成。 分区表实际上是一组对底层表的句柄对象的封装。对分区表的请求，都会通过句柄 对象转化为对存储引擎的接口调用。 分区表主要目的是将数据按照一个较粗的力度 分布在不同表中，将相关数据存放在一起，也适用于批量删除整个分区的数据。 视图5.0 版本之后引入，MySQL 在很多地方对应视图和表是同等对待的，当然也有不同， 例如不能对视图创建触发器、不能对视图使用 drop table命令等。 123456mysql&gt; create view oceania as -&gt; seelct * from county where continent = &apos;Oceania&apos; -&gt; with check option; mysql&gt; select code, name from oceania where name = &apos;Australia&apos;; MySQL 实现视图主要是使用临时表算法 和 合并算法。 若视图中包含 GROUP BY、DISTINCT、 任何聚集函数、UNION、子查询等，MySQL 都会使用临时表算法来实现视图，且此类视图都无法被更新。 在MySQL 内部存储代码MySQL 允许通过触发器、存储过程、函数的形式来存储代码， 5.1 开始，还可以在定时任务中存放代码， 也被称为 “事件”。 存储过程和函数：可以替代一些小查询，解析和网络开销明显降低 触发器：在执行 insert、update、delete 操作前后（同是只能选择一个）可以执行一些特定的操作。触发器无返回值，可以实现一些强制限制，简化应用逻辑，提高性能。MySQL 触发器“基于行的触发”设计。 事件：事件在一个独立事件调度线程中被初始化，且该线程会在执行技术后被销毁，不会放到线程缓存。 游标：MySQL 在服务器端提供只读、单向的游标，只能在存储过程或更底层的客户端api中使用。 用户自定义函数（UDF）可以使用支持C语言调用约定的任何编程语言来实现用户自定义函数，适合用作计算或与外界交互。 MySQL 中 字符集 (默认 latin1 及 ISO-8859-1)只有基于字符的值才真正的“有”字符集的概念。校对规则和字符集总是一起使用。 创建对象时的默认设置（character_set_server） 默认设置逐层继承：数据库 -&gt; 表 -&gt; 列 真正存放数据的是列，只有在创建列没有为列指定字符集时， 表的默认字符集才有用。 服务器和客户端通信时的设置（character_set_client） character_set_client -&gt; character_set_connection -&gt; character_set_result 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276mysql&gt; SHOW COLLATION;+--------------------------+----------+-----+---------+----------+---------+| Collation | Charset | Id | Default | Compiled | Sortlen |+--------------------------+----------+-----+---------+----------+---------+| big5_chinese_ci | big5 | 1 | Yes | Yes | 1 || big5_bin | big5 | 84 | | Yes | 1 || dec8_swedish_ci | dec8 | 3 | Yes | Yes | 1 || dec8_bin | dec8 | 69 | | Yes | 1 || cp850_general_ci | cp850 | 4 | Yes | Yes | 1 || cp850_bin | cp850 | 80 | | Yes | 1 || hp8_english_ci | hp8 | 6 | Yes | Yes | 1 || hp8_bin | hp8 | 72 | | Yes | 1 || koi8r_general_ci | koi8r | 7 | Yes | Yes | 1 || koi8r_bin | koi8r | 74 | | Yes | 1 || latin1_german1_ci | latin1 | 5 | | Yes | 1 || latin1_swedish_ci | latin1 | 8 | Yes | Yes | 1 || latin1_danish_ci | latin1 | 15 | | Yes | 1 || latin1_german2_ci | latin1 | 31 | | Yes | 2 || latin1_bin | latin1 | 47 | | Yes | 1 || latin1_general_ci | latin1 | 48 | | Yes | 1 || latin1_general_cs | latin1 | 49 | | Yes | 1 || latin1_spanish_ci | latin1 | 94 | | Yes | 1 || latin2_czech_cs | latin2 | 2 | | Yes | 4 || latin2_general_ci | latin2 | 9 | Yes | Yes | 1 || latin2_hungarian_ci | latin2 | 21 | | Yes | 1 || latin2_croatian_ci | latin2 | 27 | | Yes | 1 || latin2_bin | latin2 | 77 | | Yes | 1 || swe7_swedish_ci | swe7 | 10 | Yes | Yes | 1 || swe7_bin | swe7 | 82 | | Yes | 1 || ascii_general_ci | ascii | 11 | Yes | Yes | 1 || ascii_bin | ascii | 65 | | Yes | 1 || ujis_japanese_ci | ujis | 12 | Yes | Yes | 1 || ujis_bin | ujis | 91 | | Yes | 1 || sjis_japanese_ci | sjis | 13 | Yes | Yes | 1 || sjis_bin | sjis | 88 | | Yes | 1 || hebrew_general_ci | hebrew | 16 | Yes | Yes | 1 || hebrew_bin | hebrew | 71 | | Yes | 1 || tis620_thai_ci | tis620 | 18 | Yes | Yes | 4 || tis620_bin | tis620 | 89 | | Yes | 1 || euckr_korean_ci | euckr | 19 | Yes | Yes | 1 || euckr_bin | euckr | 85 | | Yes | 1 || koi8u_general_ci | koi8u | 22 | Yes | Yes | 1 || koi8u_bin | koi8u | 75 | | Yes | 1 || gb2312_chinese_ci | gb2312 | 24 | Yes | Yes | 1 || gb2312_bin | gb2312 | 86 | | Yes | 1 || greek_general_ci | greek | 25 | Yes | Yes | 1 || greek_bin | greek | 70 | | Yes | 1 || cp1250_general_ci | cp1250 | 26 | Yes | Yes | 1 || cp1250_czech_cs | cp1250 | 34 | | Yes | 2 || cp1250_croatian_ci | cp1250 | 44 | | Yes | 1 || cp1250_bin | cp1250 | 66 | | Yes | 1 || cp1250_polish_ci | cp1250 | 99 | | Yes | 1 || gbk_chinese_ci | gbk | 28 | Yes | Yes | 1 || gbk_bin | gbk | 87 | | Yes | 1 || latin5_turkish_ci | latin5 | 30 | Yes | Yes | 1 || latin5_bin | latin5 | 78 | | Yes | 1 || armscii8_general_ci | armscii8 | 32 | Yes | Yes | 1 || armscii8_bin | armscii8 | 64 | | Yes | 1 || utf8_general_ci | utf8 | 33 | Yes | Yes | 1 || utf8_bin | utf8 | 83 | | Yes | 1 || utf8_unicode_ci | utf8 | 192 | | Yes | 8 || utf8_icelandic_ci | utf8 | 193 | | Yes | 8 || utf8_latvian_ci | utf8 | 194 | | Yes | 8 || utf8_romanian_ci | utf8 | 195 | | Yes | 8 || utf8_slovenian_ci | utf8 | 196 | | Yes | 8 || utf8_polish_ci | utf8 | 197 | | Yes | 8 || utf8_estonian_ci | utf8 | 198 | | Yes | 8 || utf8_spanish_ci | utf8 | 199 | | Yes | 8 || utf8_swedish_ci | utf8 | 200 | | Yes | 8 || utf8_turkish_ci | utf8 | 201 | | Yes | 8 || utf8_czech_ci | utf8 | 202 | | Yes | 8 || utf8_danish_ci | utf8 | 203 | | Yes | 8 || utf8_lithuanian_ci | utf8 | 204 | | Yes | 8 || utf8_slovak_ci | utf8 | 205 | | Yes | 8 || utf8_spanish2_ci | utf8 | 206 | | Yes | 8 || utf8_roman_ci | utf8 | 207 | | Yes | 8 || utf8_persian_ci | utf8 | 208 | | Yes | 8 || utf8_esperanto_ci | utf8 | 209 | | Yes | 8 || utf8_hungarian_ci | utf8 | 210 | | Yes | 8 || utf8_sinhala_ci | utf8 | 211 | | Yes | 8 || utf8_german2_ci | utf8 | 212 | | Yes | 8 || utf8_croatian_ci | utf8 | 213 | | Yes | 8 || utf8_unicode_520_ci | utf8 | 214 | | Yes | 8 || utf8_vietnamese_ci | utf8 | 215 | | Yes | 8 || utf8_general_mysql500_ci | utf8 | 223 | | Yes | 1 || ucs2_general_ci | ucs2 | 35 | Yes | Yes | 1 || ucs2_bin | ucs2 | 90 | | Yes | 1 || ucs2_unicode_ci | ucs2 | 128 | | Yes | 8 || ucs2_icelandic_ci | ucs2 | 129 | | Yes | 8 || ucs2_latvian_ci | ucs2 | 130 | | Yes | 8 || ucs2_romanian_ci | ucs2 | 131 | | Yes | 8 || ucs2_slovenian_ci | ucs2 | 132 | | Yes | 8 || ucs2_polish_ci | ucs2 | 133 | | Yes | 8 || ucs2_estonian_ci | ucs2 | 134 | | Yes | 8 || ucs2_spanish_ci | ucs2 | 135 | | Yes | 8 || ucs2_swedish_ci | ucs2 | 136 | | Yes | 8 || ucs2_turkish_ci | ucs2 | 137 | | Yes | 8 || ucs2_czech_ci | ucs2 | 138 | | Yes | 8 || ucs2_danish_ci | ucs2 | 139 | | Yes | 8 || ucs2_lithuanian_ci | ucs2 | 140 | | Yes | 8 || ucs2_slovak_ci | ucs2 | 141 | | Yes | 8 || ucs2_spanish2_ci | ucs2 | 142 | | Yes | 8 || ucs2_roman_ci | ucs2 | 143 | | Yes | 8 || ucs2_persian_ci | ucs2 | 144 | | Yes | 8 || ucs2_esperanto_ci | ucs2 | 145 | | Yes | 8 || ucs2_hungarian_ci | ucs2 | 146 | | Yes | 8 || ucs2_sinhala_ci | ucs2 | 147 | | Yes | 8 || ucs2_german2_ci | ucs2 | 148 | | Yes | 8 || ucs2_croatian_ci | ucs2 | 149 | | Yes | 8 || ucs2_unicode_520_ci | ucs2 | 150 | | Yes | 8 || ucs2_vietnamese_ci | ucs2 | 151 | | Yes | 8 || ucs2_general_mysql500_ci | ucs2 | 159 | | Yes | 1 || cp866_general_ci | cp866 | 36 | Yes | Yes | 1 || cp866_bin | cp866 | 68 | | Yes | 1 || keybcs2_general_ci | keybcs2 | 37 | Yes | Yes | 1 || keybcs2_bin | keybcs2 | 73 | | Yes | 1 || macce_general_ci | macce | 38 | Yes | Yes | 1 || macce_bin | macce | 43 | | Yes | 1 || macroman_general_ci | macroman | 39 | Yes | Yes | 1 || macroman_bin | macroman | 53 | | Yes | 1 || cp852_general_ci | cp852 | 40 | Yes | Yes | 1 || cp852_bin | cp852 | 81 | | Yes | 1 || latin7_estonian_cs | latin7 | 20 | | Yes | 1 || latin7_general_ci | latin7 | 41 | Yes | Yes | 1 || latin7_general_cs | latin7 | 42 | | Yes | 1 || latin7_bin | latin7 | 79 | | Yes | 1 || utf8mb4_general_ci | utf8mb4 | 45 | Yes | Yes | 1 || utf8mb4_bin | utf8mb4 | 46 | | Yes | 1 || utf8mb4_unicode_ci | utf8mb4 | 224 | | Yes | 8 || utf8mb4_icelandic_ci | utf8mb4 | 225 | | Yes | 8 || utf8mb4_latvian_ci | utf8mb4 | 226 | | Yes | 8 || utf8mb4_romanian_ci | utf8mb4 | 227 | | Yes | 8 || utf8mb4_slovenian_ci | utf8mb4 | 228 | | Yes | 8 || utf8mb4_polish_ci | utf8mb4 | 229 | | Yes | 8 || utf8mb4_estonian_ci | utf8mb4 | 230 | | Yes | 8 || utf8mb4_spanish_ci | utf8mb4 | 231 | | Yes | 8 || utf8mb4_swedish_ci | utf8mb4 | 232 | | Yes | 8 || utf8mb4_turkish_ci | utf8mb4 | 233 | | Yes | 8 || utf8mb4_czech_ci | utf8mb4 | 234 | | Yes | 8 || utf8mb4_danish_ci | utf8mb4 | 235 | | Yes | 8 || utf8mb4_lithuanian_ci | utf8mb4 | 236 | | Yes | 8 || utf8mb4_slovak_ci | utf8mb4 | 237 | | Yes | 8 || utf8mb4_spanish2_ci | utf8mb4 | 238 | | Yes | 8 || utf8mb4_roman_ci | utf8mb4 | 239 | | Yes | 8 || utf8mb4_persian_ci | utf8mb4 | 240 | | Yes | 8 || utf8mb4_esperanto_ci | utf8mb4 | 241 | | Yes | 8 || utf8mb4_hungarian_ci | utf8mb4 | 242 | | Yes | 8 || utf8mb4_sinhala_ci | utf8mb4 | 243 | | Yes | 8 || utf8mb4_german2_ci | utf8mb4 | 244 | | Yes | 8 || utf8mb4_croatian_ci | utf8mb4 | 245 | | Yes | 8 || utf8mb4_unicode_520_ci | utf8mb4 | 246 | | Yes | 8 || utf8mb4_vietnamese_ci | utf8mb4 | 247 | | Yes | 8 || cp1251_bulgarian_ci | cp1251 | 14 | | Yes | 1 || cp1251_ukrainian_ci | cp1251 | 23 | | Yes | 1 || cp1251_bin | cp1251 | 50 | | Yes | 1 || cp1251_general_ci | cp1251 | 51 | Yes | Yes | 1 || cp1251_general_cs | cp1251 | 52 | | Yes | 1 || utf16_general_ci | utf16 | 54 | Yes | Yes | 1 || utf16_bin | utf16 | 55 | | Yes | 1 || utf16_unicode_ci | utf16 | 101 | | Yes | 8 || utf16_icelandic_ci | utf16 | 102 | | Yes | 8 || utf16_latvian_ci | utf16 | 103 | | Yes | 8 || utf16_romanian_ci | utf16 | 104 | | Yes | 8 || utf16_slovenian_ci | utf16 | 105 | | Yes | 8 || utf16_polish_ci | utf16 | 106 | | Yes | 8 || utf16_estonian_ci | utf16 | 107 | | Yes | 8 || utf16_spanish_ci | utf16 | 108 | | Yes | 8 || utf16_swedish_ci | utf16 | 109 | | Yes | 8 || utf16_turkish_ci | utf16 | 110 | | Yes | 8 || utf16_czech_ci | utf16 | 111 | | Yes | 8 || utf16_danish_ci | utf16 | 112 | | Yes | 8 || utf16_lithuanian_ci | utf16 | 113 | | Yes | 8 || utf16_slovak_ci | utf16 | 114 | | Yes | 8 || utf16_spanish2_ci | utf16 | 115 | | Yes | 8 || utf16_roman_ci | utf16 | 116 | | Yes | 8 || utf16_persian_ci | utf16 | 117 | | Yes | 8 || utf16_esperanto_ci | utf16 | 118 | | Yes | 8 || utf16_hungarian_ci | utf16 | 119 | | Yes | 8 || utf16_sinhala_ci | utf16 | 120 | | Yes | 8 || utf16_german2_ci | utf16 | 121 | | Yes | 8 || utf16_croatian_ci | utf16 | 122 | | Yes | 8 || utf16_unicode_520_ci | utf16 | 123 | | Yes | 8 || utf16_vietnamese_ci | utf16 | 124 | | Yes | 8 || utf16le_general_ci | utf16le | 56 | Yes | Yes | 1 || utf16le_bin | utf16le | 62 | | Yes | 1 || cp1256_general_ci | cp1256 | 57 | Yes | Yes | 1 || cp1256_bin | cp1256 | 67 | | Yes | 1 || cp1257_lithuanian_ci | cp1257 | 29 | | Yes | 1 || cp1257_bin | cp1257 | 58 | | Yes | 1 || cp1257_general_ci | cp1257 | 59 | Yes | Yes | 1 || utf32_general_ci | utf32 | 60 | Yes | Yes | 1 || utf32_bin | utf32 | 61 | | Yes | 1 || utf32_unicode_ci | utf32 | 160 | | Yes | 8 || utf32_icelandic_ci | utf32 | 161 | | Yes | 8 || utf32_latvian_ci | utf32 | 162 | | Yes | 8 || utf32_romanian_ci | utf32 | 163 | | Yes | 8 || utf32_slovenian_ci | utf32 | 164 | | Yes | 8 || utf32_polish_ci | utf32 | 165 | | Yes | 8 || utf32_estonian_ci | utf32 | 166 | | Yes | 8 || utf32_spanish_ci | utf32 | 167 | | Yes | 8 || utf32_swedish_ci | utf32 | 168 | | Yes | 8 || utf32_turkish_ci | utf32 | 169 | | Yes | 8 || utf32_czech_ci | utf32 | 170 | | Yes | 8 || utf32_danish_ci | utf32 | 171 | | Yes | 8 || utf32_lithuanian_ci | utf32 | 172 | | Yes | 8 || utf32_slovak_ci | utf32 | 173 | | Yes | 8 || utf32_spanish2_ci | utf32 | 174 | | Yes | 8 || utf32_roman_ci | utf32 | 175 | | Yes | 8 || utf32_persian_ci | utf32 | 176 | | Yes | 8 || utf32_esperanto_ci | utf32 | 177 | | Yes | 8 || utf32_hungarian_ci | utf32 | 178 | | Yes | 8 || utf32_sinhala_ci | utf32 | 179 | | Yes | 8 || utf32_german2_ci | utf32 | 180 | | Yes | 8 || utf32_croatian_ci | utf32 | 181 | | Yes | 8 || utf32_unicode_520_ci | utf32 | 182 | | Yes | 8 || utf32_vietnamese_ci | utf32 | 183 | | Yes | 8 || binary | binary | 63 | Yes | Yes | 1 || geostd8_general_ci | geostd8 | 92 | Yes | Yes | 1 || geostd8_bin | geostd8 | 93 | | Yes | 1 || cp932_japanese_ci | cp932 | 95 | Yes | Yes | 1 || cp932_bin | cp932 | 96 | | Yes | 1 || eucjpms_japanese_ci | eucjpms | 97 | Yes | Yes | 1 || eucjpms_bin | eucjpms | 98 | | Yes | 1 || gb18030_chinese_ci | gb18030 | 248 | Yes | Yes | 2 || gb18030_bin | gb18030 | 249 | | Yes | 1 || gb18030_unicode_520_ci | gb18030 | 250 | | Yes | 8 |+--------------------------+----------+-----+---------+----------+---------+222 rows in set (0.00 sec)mysql&gt; show character set;+----------+---------------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+---------------------------------+---------------------+--------+| big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 || latin1 | cp1252 West European | latin1_swedish_ci | 1 || latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 || swe7 | 7bit Swedish | swe7_swedish_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || ujis | EUC-JP Japanese | ujis_japanese_ci | 3 || sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 || hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 || tis620 | TIS620 Thai | tis620_thai_ci | 1 || euckr | EUC-KR Korean | euckr_korean_ci | 2 || koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 || gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 || greek | ISO 8859-7 Greek | greek_general_ci | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 || latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 || armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || utf8 | UTF-8 Unicode | utf8_general_ci | 3 || ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 || cp866 | DOS Russian | cp866_general_ci | 1 || keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 || macce | Mac Central European | macce_general_ci | 1 || macroman | Mac West European | macroman_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 || utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 || cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || utf16 | UTF-16 Unicode | utf16_general_ci | 4 || utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || utf32 | UTF-32 Unicode | utf32_general_ci | 4 || binary | Binary pseudo charset | binary | 1 || geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 || gb18030 | China National Standard GB18030 | gb18030_chinese_ci | 4 |+----------+---------------------------------+---------------------+--------+41 rows in set (0.00 sec) 全文索引开始只有MyISAM 存储引擎支持，MySQL 5.6 中InnoDB开始支持。 其实要做全局索引，完全可以使用其他解决方案, 例如：Sphinx、Lucene、Solr、Groonga、Xaoian、Senna 分布式事务（XA）是一种在多个服务器之间同步数据的方法 第一阶段：XA事务协调器需要保证所有事务参与者都完成了准备工作 第二阶段：协调器收到所有参与者发来的消息，告诉所有是事务可以提交 查询缓存MySQL 查询缓存保存查询返还的完整结果。当查询命中该缓存时，会立刻返回结果，跳过解析、优化和执行阶段。根据经验来看，在高并发的情况下，查询缓存会导致系统的性能下降。若希望有更高的缓存效率，建议使用memcahced 等其他类似解决方案来进行替代。 9. 复制1. 概述MySQL 内建的复制功能是构建基于MySQL 的大规模、高性能应用的基础，这类应用使用所谓的 “水平扩展”的架构，通过为服务器配置一个或多个备库的方式来实现数据同步。 MySQL 支持两种复制方式：基于行的复制和基于语句的复制。 基于语句的复制（逻辑复制）：在MySQL 3.23 版本中就存在 基于行的复制：5.1 版本中才被引入。 通过在主库上记录二进制日志，在备库重放日志的形式来实现异步的数据复制。所以同一时间，主库与从库数据可能会存在不一致的现象。 注意： MySQL 复制大部分是向后兼容，新版本服务器可以作为老版本服务器的备库，但是反过来往往不行。 2. 复制解决的问题 数据分布 在不同地理位置来实现分布数据备份 负载均衡 将读操作分布到多个服务器上，实现读写分离 备份 作为数据备份的一项技术补充 高可用和故障切换 帮助应用程序避免MySQL单点失败 MySQL升级测试 使用一个高版本的MySQL作为备库，保证在升级全部实例前，查询能够在备库按照预期执行。 3. 基于Docker 的MySQL 主从复制测试由于资源有限，虚拟机、mysql等配置繁琐，而Docker容器之间相互独立，有独立ip，互不冲突，本着学无止境的精神，故选择在本地已经配置好Docker 的 一 CentOS 虚拟机学习搭建MySQL 主从服务器。 首先拉取docker镜像,我们这里使用5.7.24版本的mysql： 12345678# 查找 mysql 镜像, 去docker hub可以查看镜像版本docker search mysql# 拉取 mysql 5.7.24 镜像到本地docker pull mysql:5.7.24# 查看本地镜像docker images 使用此镜像启动两个 MySQL 实例容器 12345# 主（master）docker run -p 3339:3306 --name mysql_master -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.24# 从（slave）docker run -p 3340:3306 --name mysql_slave1 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.24 -p 外部端口:内部端口 端口映射 – name 自定义启动容器名字 -e MYSQL_ROOT_PASSWORD=123456 定义mysql 容器root密码为123456 -d 容器后台运行 mysql:5.7.24 运行mysql:5.7.24 镜像 因为docker容器是相互独立的，每个容器有其独立的ip，所以不同容器使用相同的端口并不会冲突 1234[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESfc8b11595f99 mysql:5.7.24 "docker-entrypoint..." 4 minutes ago Up 4 minutes 33060/tcp, 0.0.0.0:3340-&gt;3306/tcp mysql_slave10bc8050bd989 mysql:5.7.24 "docker-entrypoint..." 6 minutes ago Up 6 minutes 33060/tcp, 0.0.0.0:3339-&gt;3306/tcp mysql_master 配置主库Master 12345678910111213docker exec -it mysql_master /bin/bash# 切换到 /etc/mysql 目录cd /etc/mysql# 对 my.cnf 进项配置vim my.cnf# 提示。。。。。。好吧。。。root@0bc8050bd989:/etc/mysql# cat /etc/issueDebian GNU/Linux 9 \n \l# 这玩意基于 Debian 啊。好吧！apt-get uddateapt-get install vim# 软件源速度比较慢。。。静静等待。。。vim my.cnf 在my.cnf 内进进行如下配置 12345[mysqld]## 同一局域网内注意要唯一server-id=100 ## 开启二进制日志功能，可以随便取（关键）log-bin=mysql-bin 1234# 重启mysql 服务，使配置文件生效service mysql restart# 重启docker 容器docker start mysql_master 在master数据库创建数据同步用户，授予用户 slave REPLICATION SLAVE权限和REPLICATION CLIENT权限，用于在主从库之间同步数据。 12345mysql&gt; CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;Query OK, 0 rows affectedmysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;;Query OK, 0 rows affected 配置从库Slave 和配置Master(主)一样，在Slave配置文件my.cnf中添加如下配置： 1234567[mysqld]## 设置server_id,注意要唯一server-id=101 ## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用log-bin=mysql-slave-bin ## relay_log配置中继日志relay_log=edu-mysql-relay-bin 配置完成后也需要重启mysql服务和docker容器，操作和配置Master(主)一致。 链接Master（主）和 Slave（从） Master 进入mysql 执行 show master status 1234567mysql&gt; show master status;+------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 | 609 | | | |+------------------+----------+--------------+------------------+-------------------+1 row in set Slave 进入 mysql 执行 12345678mysql&gt; change master to master_host=&apos;172.17.0.2&apos;,master_user=&apos;slave&apos;,master_password=&apos;123456&apos;, master_port=3306, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos= 609, master_connect_retry=30;Query OK, 0 rows affected 说明： master_host ：Master的地址，指的是容器的独立ip,可以通过 1docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' 容器名称|容器id 查询容器的ip 1234[root@localhost ~]# docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' mysql_master172.17.0.2[root@localhost ~]# docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' mysql_slave1172.17.0.3 master_port：Master的端口号，指的是容器的端口号 master_user：用于数据同步的用户 master_password：用于同步的用户的密码 master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值 master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值 master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是60秒 Slave 端执行 show slave status \G 查看主从同步状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960mysql&gt; show slave status \G*************************** 1. row *************************** Slave_IO_State: Master_Host: 172.17.0.2 Master_User: slave Master_Port: 3306 Connect_Retry: 30 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 609 Relay_Log_File: edu-mysql-relay-bin.000001 Relay_Log_Pos: 4 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: No Slave_SQL_Running: No Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 609 Relay_Log_Space: 154 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: NULLMaster_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 0 Master_UUID: Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) SlaveIORunning 和 SlaveSQLRunning 都是No，因为我们还没有开启主从复制过程。 使用start slave开启主从复制过程，然后再次查询主从同步状态show slave status \G; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mysql&gt; start slave;Query OK, 0 rows affected (0.19 sec)mysql&gt; show slave status \G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 172.17.0.2 Master_User: slave Master_Port: 3306 Connect_Retry: 30 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 609 Relay_Log_File: edu-mysql-relay-bin.000002 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 609 Relay_Log_Space: 531 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 100 Master_UUID: a370118a-fd4e-11e8-ad2f-0242ac110002 Master_Info_File: /var/lib/mysql/master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version: 1 row in set (0.00 sec) SlaveIORunning 和 SlaveSQLRunning 都是Yes，说明主从复制已经开启。此时可以测试数据同步是否成功。 测试主从复制 1234567891011121314151617181920212223242526272829# Master 创建 test 数据库mysql&gt; create database test;Query OK, 1 row affectedmysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test |+--------------------+5 rows in set# Slave从库查看数据库mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys || test |+--------------------+5 rows in set 至此两个数据库同步成功！ 4. 从另一台服务器开始复制上述测试为两台新服务器配置主从复制，而通常情况下是一个已经运行了一段时间的主库，然后用一台新安装的备库与之同步。下面是一些从其他数据库备份数据库到从库的方法： 冷备份：关闭主库，将数据复制到备库 热备份：若仅使用MyISAM 表，可以在运行时使用mysqlhotcopy 或 rsync 来复制数据 使用mysqldump：若仅适用InnoDB表，可以使用 mysqldump --single-transaction --all-databases --master-data=1--host=master | mysql --host=slave 使用快照或备份：只需知道对应的二进制日志坐标，就可以使用主库的快照或备份来初始化从库 使用 Percona Xtrabackup：一款开源的热备份工具 使用另外的从库 5. 复制的原理1. 基于语句的复制MySQL 5.0 之前版本只支持基于语句的复制（逻辑复制）。主库记录那些造成更改的查询，当备库读取并重放这些事件时，实际上是将主库执行的SQL再执行一遍。 优点就是实现比较简单，日志文件比较紧凑。缺点是无法考虑其他因素，例如若主库执行语句使用了当前时间戳或CURRENT_USER() 函数、触发器、存储过程等，可能就无法完整复现。还有串行化的更新使用更多的锁，造成性能下降。 2. 基于行的复制MySQL 5.1 开始支持基于行的复制。将实际数据记录在二进制日志中，所以无需重放主库数据的查询，效率与基于语句的复制相比会更高一些。当时由于基于行的复制记录的是实际数据，在做一些简单的update操作时会将全表更新，意味着日志文件会写入全表数据，使得日志记录效率降低。 所以：实际上MySQL 会在来年两种复制模式之间动态切换。默认情况下使用的是基于语句的复制方式，但如果发现语句无法被正确复制，就会切换到基于行的复制复制模式。 3. 复制文件开启复制后除了 二进制日志文件和中继日志文件，还会使用其他一些文件。 mysql-bin.index: 这个文件每一行都包含了二进制文件的文件名 mysql-relay-bin-index: 中继日志文件索引文件 master.info: 保存备库连接到主库所需的信息（纯文本） relay-log.info: 此文件包含了当前备库复制的二进制日志和中继日志坐标 5. 发送复制事件到其他备库log_slave_udpates 选项可以让备库变成其他服务器的主库 6. 复制过滤 主库过滤记录到二进制文件 备库过滤记录到中继日志文件 7. 复制拓扑 一个MySQL 备库实例只能有一个主库（MySQL 不支持多主复制） 每个备库必须有一个唯一的服务器ID 一个主库可以有多个备库 若打开了 log_slave_updates 选项，一个备库可以将其主库上的数据变化传播到其他备库]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java方向技术面试常见问题及答案]]></title>
    <url>%2F2019%2F01%2F06%2FJava%E6%96%B9%E5%90%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[声明 本文作者:微信公众号JavaQ 原文链接:Java方向如何准备BAT技术面试答案(转) 面向对象和面向过程的区别面向过程 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 Java 的四个基本特性（抽象、封装、继承，多态）抽象 就是把现实生活中的某一类东西提取出来，用程序代码表示，我们通常叫做类或者接口。 抽象包括两个方面：一个是数据抽象，一个是过程抽象。 数据抽象也就是对象的属性。过程抽象是对象的行为特征。 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行封装隐藏。 封装分为属性的封装和方法的封装。 继承 是对有着共同特性的多类事物，进行再抽象成一个类。这个类就是多类事物的父类。 父类的意义在于抽取多类事物的共性。 多态 允许不同类的对象对同一消息做出响应。 方法的重载、类的覆盖正体现了多态。 重载和重写的区别重载发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 重写发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类中就不是重写。 构造器 Constructor 是否可被 override构造器不能被重写，不能用static修饰构造器，只能用 publicprivate protected 这三个权限修饰符，且不能有返回语句。 访问控制符 public,protected,private,以及 默认 的区别private只有在本类中才能访问 public在任何地方都能访问 protected在同包内的类及包外的子类能访问 默认在同包内能访问 是否可以继承 String 类 String 类是 final 类故不可以继承 一切由 final 修饰过的都不能继承 String 和 StringBuffer、StringBuilder 的区别可变性 String 类中使用字符数组保存字符串，private final char value[]，所以 string 对象是不可变的。 StringBuilder 与 StringBuffer 都继承自AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。 线程安全性 String 中的对象是不可变的，也就可以理解为常量，线程安全。 AbstractStringBuilder 是 StringBuilder与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf等公共方法。 StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。 StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 hashCode 和 equals方法的关系 equals 相等，hashcode 必相等 hashcode 相等，equals 可能不相等。 抽象类和接口的区别语法层次抽象类和接口分别给出了不同的语法定义。 设计层次 抽象层次不同，抽象类是对类抽象，而接口是对行为的抽象。 抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。 抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 跨域不同 抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在 “is-a” 关系，即父类和派生类在概念本质上应该是相同的。 对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的，仅仅是实现了接口定义的契约而已，”like-a” 的关系。 自动装箱与拆箱 装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； Java使用自动装箱和拆箱机制，节省了常用数值的内存开销和创建对象的开销，提高了效率，由编译器来完成，编译器会在编译期根据语法决定是否进行装箱和拆箱动作。 什么是泛型、为什么要使用以及泛型擦除泛型，即“参数化类型”。 创建集合时就指定集合元素的类型，该集合只能保存其指定类型的元素，避免使用强制类型转换。 Java 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程即类型擦除。 泛型擦除可以简单的理解为将泛型java 代码转换为普通 java 代码，只不过编译器更直接点，将泛型 java 代码直接转换成普通 java 字节码。 类型擦除的主要过程 将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。 移除所有的类型参数。 Java 中的集合类及关系图 List 和 Set 继承自 Collection 接口。 Set 无序不允许元素重复。HashSet 和 TreeSet 是两个主要的实现类。List 有序且允许元素重复。ArrayList、LinkedList 和 Vector 是三个主要的实现类。 Map 也属于集合系统，但和 Collection接口没关系。Map 是 key 对 value 的映射集合，其中 key 列就是一个集合。key 不能重复，但是value 可以重复。HashMap、TreeMap 和 Hashtable 是三个主要的实现类。 SortedSet 和 SortedMap 接口对元素按指定规则排序，SortedMap 是对 key 列进行排序。 HashMap 实现原理具体原理参考文章： 深入Java集合学习系列：HashMap的实现原理 HashMap的工作原理 HashTable 实现原理具体原理参考文章： Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例 【源码】Hashtable源码剖析 HashMap 和 HashTable区别 HashTable 的方法前面都有 synchronized 来同步，是线程安全的；HashMap 未经同步，是非线程安全的。 HashTable 不允许 null 值( key 和 value 都不可以)；HashMap 允许 null 值( key 和 value 都可以)。 HashTable 有一个 contains ( Object value ) 功能和containsValue ( Object value ) 功能一样。 HashTable 使用 Enumeration 进行遍历；HashMap 使用 Iterator 进行遍历。 HashTable 中 hash 数组默认大小是 11，增加的方式是 old*2+1；HashMap 中 hash 数组的默认大小是 16，而且一定是 2 的指数。 哈希值的使用不同，HashTable 直接使用对象的 hashCode； HashMap 重新计算 hash 值，而且用与代替求模。 ArrayList 和 vector 区别 ArrayList 和 Vector 都实现了 List 接口，都是通过数组实现的。 Vector 是线程安全的，而 ArrayList 是非线程安全的。 List 第一次创建的时候，会有一个初始大小，随着不断向 List 中增加元素，当 List 认为容量不够的时候就会进行扩容。 Vector 缺省情况下自动增长原来一倍的数组长度，ArrayList 增长原来的 50%。 ArrayList 和 LinkedList 区别及使用场景区别 ArrayList 底层是用数组实现的，可以认为 ArrayList 是一个可改变大小的数组。随着越来越多的元素被添加到 ArrayList中，其规模是动态增加的。 LinkedList 底层是通过双向链表实现的， LinkedList 和 ArrayList相比，增删的速度较快。但是查询和修改值的速度较慢。同时，LinkedList 还实现了Queue接口，所以他还提供了 offer(), peek(), poll() 等方法 使用场景 LinkedList 更适合从中间插入或者删除（链表的特性）。 ArrayList 更适合检索和在末尾插入或删除（数组的特性）。 Collection 和 Collections 的区别 java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。 java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。 ConcurrentHashMap 实现原理具体原理参考文章： Java集合—ConcurrentHashMap原理分析 聊聊并发（四）深入分析ConcurrentHashMap Error、Exception 区别Error 类和 Exception 类的父类都是 throwable 类 区别 Error 类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。 Exception 类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。 Unchecked Exception 和 Checked ExceptionUnchecked Exception: 指的是程序的瑕疵或逻辑错误，并且在运行时无法恢复。 包括 Error 与 RuntimeException 及其子类，如：OutOfMemoryError, UndeclaredThrowableException, IllegalArgumentException, IllegalMonitorStateException, NullPointerException, IllegalStateException, IndexOutOfBoundsException 等。 语法上不需要声明抛出异常。 Checked Exception: 代表程序不能直接控制的无效外界情况（如用户输入，数据库问题，网络异常，文件丢失等） 除了 Error 和 RuntimeException 及其子类之外，如：ClassNotFoundException, NamingException, ServletException, SQLException, IOException 等。 需要 try catch 处理或 throws 声明抛出异常。 Java 中如何实现代理机制 (JDK、CGLIB) JDK 动态代理：代理类和目标类实现了共同的接口，用到 InvocationHandler 接口。 CGLIB 动态代理：代理类是目标类的子类，用到 MethodInterceptor 接口。 多线程的实现方式 继承 Thread 类 实现 Runnable 接口 使用 ExecutorService、Callable、Future 实现有返回结果的多线程。 线程的状态转换 如何停止一个线程参考文章： 如何正确地停止一个线程？ 什么是线程安全线程安全就是多线程访问同一代码，不会产生不确定的结果。 如何保证线程安全 对非安全的代码进行加锁控制； 使用线程安全的类； 多线程并发情况下，线程共享的变量改为方法级的局部变量。 synchronized 如何使用synchronized是Java中的关键字，是一种同步锁。 修饰的对象： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是 synchronized 后面括号括起来的部分，作用主的对象是这个类的所有对象。 synchronized 和 Lock 的区别主要相同点Lock 能完成 synchronized 所实现的所有功能 主要不同点 Lock 有比 synchronized 更精确的线程语义和更好的性能。 Lock 的锁定是通过代码实现的，而 synchronized 是在JVM层面上实现的，synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且必须在 finally 从句中释放。 Lock 还有更强大的功能，例如，它的 tryLock 方法可以非阻塞方式去拿锁。 Lock 锁的范围有局限性，块范围，而 synchronized 可以锁住块、对象、类。 多线程如何进行信息交互 void notify() 唤醒在此对象监视器上等待的单个线程。 void notifyAll() 唤醒在此对象监视器上等待的所有线程。 void wait() 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 void wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 void wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 sleep 和 wait 的区别(考察的方向是是否会释放锁) sleep() 方法是 Thread 类中方法，而 wait() 方法是Object类中的方法。 sleep() 方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态，在调用 sleep() 方法的过程中，线程不会释放对象锁。 而当调用 wait() 方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用 notify() 方法后本线程才进入对象锁定池准备。 多线程与死锁死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 产生死锁的原因 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当。 如何才能产生死锁产生死锁的四个必要条件 互斥条件：所谓互斥就是进程在某一时间内独占资源。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系。 死锁的预防打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。 打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。 打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。 打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。 打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。 什么叫守护线程，用什么方法实现守护线程 守护线程是为其他线程的运行提供服务的线程。 setDaemon( boolean on ) 方法可以方便的设置线程的 Daemon 模式，true 为守护模式，false 为用户模式。 Java 线程池技术及原理参考文章： 深入理解Java之线程池 Java并发编程：线程池的使用 java 并发包 concurrent 及常用的类这个内容有点多，参考文章： 并发包诸类概览：java.util.concurrent并发包诸类概览 线程池：Java并发编程：线程池的使用 锁：Java并发编程：Lock 集合：java中并发包简要分析01 volatile 关键字 用 volatile 修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile 很容易被误用，用来进行原子性操作。 Java语言中的 volatile 变量可以被看作是一种“程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。 锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。可见性必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的，如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。 要使volatile变量提供理想的线程安全，必须同时满足下面两个条件： 对变量的写操作不依赖于当前值； 该变量没有包含在具有其他变量的不变式中。 第一个条件的限制使volatile变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而volatile不能提供必须的原子特性。实现正确的操作需要使x 的值在操作期间保持不变，而volatile变量无法实现这点。 每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。read and load 从主存复制变量到当前工作内存use and assign 执行代码，改变共享变量值store and write 用工作内存数据刷新主存相关内容其中 use and assign 可以多次出现，但是这一些操作并不是原子性，也就是在 read load 之后，如果主内存 count 变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样。 Java中的 NIO，BIO，AIO 分别是什么BIO 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。 NIO 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4 开始支持。 AIO 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理. AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK 7 开始支持。 IO 和 NIO 区别 IO 是面向流的，NIO 是面向缓冲区的。 IO的各种流是阻塞的，NIO是非阻塞模式。 Java NIO 的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。 序列化与反序列化 把对象转换为字节序列的过程称为对象的序列化。 把字节序列恢复为对象的过程称为对象的反序列化。 对象的序列化主要有两种用途： 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中； 在网络上传送对象的字节序列。 当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。 发送方需要把这个 Java 对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为 Java 对象。 常见的序列化协议有哪些Protobuf, Thrift, Hessian, Kryo 内存溢出和内存泄漏的区别 内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。 内存泄漏是指分配出去的内存不再使用，但是无法回收。 Java 内存模型及各个区域的 OOM，如何重现 OOM这部分内容很重要，详细阅读《深入理解 Java 虚拟机》，也可以详细阅读这篇文章 JVM内存管理：深入Java内存区域与OOM 出现OOM如何解决 可通过命令定期抓取 heap dump 或者启动参数 OOM 时自动抓取 heap dump 文件。 通过对比多个 heap dump，以及 heap dump 的内容，分析代码找出内存占用最多的地方。 分析占用的内存对象，是否是因为错误导致的内存未及时释放，或者数据过多导致的内存溢出。 用什么工具可以查出内存泄漏 Memory Analyzer－是一款开源的 JAVA 内存分析软件，查找内存泄漏，能容易找到大块内存并验证谁在一直占用它，它是基于 Eclipse RCP(Rich Client Platform)，可以下载 RCP 的独立版本或者 Eclipse 的插件。 JProbe－分析 Java 的内存泄漏。 JProfiler－一个全功能的 Java 剖析工具，专用于分析 J2SE 和 J2EE 应用程序。它把 CPU、执行绪 和 内存 的剖析组合在一个强大的应用中，GUI 可以找到效能瓶颈、抓出内存泄漏、并解决执行绪的问题。 JRockit－用来诊断 Java 内存泄漏并指出根本原因，专门针对 Intel 平台并得到优化，能在 Intel 硬件上获得最高的性能。 YourKit-.NET &amp; Java Profiling 业界领先的 Java 和 .NET 程序性能分析工具。6.AutomatedQA －AutomatedQA 的获奖产品 performance profiling 和 memory debugging 工具集的下一代替换产品，支持 Microsoft,Borland, Intel, Compaq 和 GNU 编译器。可以为 .NET 和 Windows 程序生成全面细致的报告，从而帮助您轻松隔离并排除代码中含有的性能问题和内存/资源泄露问题。支持 .Net 1.0,1.1,2.0,3.0 和 Windows 32/64 位应用程序。7.Compuware DevPartner Java Edition－包含 Java 内存检测,代码覆盖率测试,代码性能测试,线程死锁,分布式应用等几大功能模块 Java 内存管理及回收算法阅读这篇文章： Java 内存区域和GC机制 Java 类加载器及如何加载类(双亲委派)阅读文章： 深入探讨 Java 类加载器 深入理解Java类加载器(1)：Java类加载原理解析 XML 解析方式 DOM(JAXP Crimson解析器) SAX JDOM DOM4J 区别： DOM4J 性能最好，连 Sun 的 JAXM 也在用 DOM4J。目前许多开源项目中大量采用 DOM4J，例如大名鼎鼎的 hibernate 也用 DOM4J 来读取 XML 配置文件。如果不考虑可移植性，那就采用 DOM4J. JDOM 和 DOM 在性能测试时表现不佳，在测试 10M 文档时内存溢出。在小文档情况下还值得考虑使用 DOM 和 JDOM。虽然 JDOM 的开发者已经说明他们期望在正式发行版前专注性能问题，但是从性能观点来看，它确实没有值得推荐之处。另外，DOM 仍是一个非常好的选择。DOM 实现广泛应用于多种编程语言。它还是许多其它与 XML 相关的标准的基础，因为它正式获得 W3C 推荐 ( 与基于非标准的 Java 模型相对 )，所以在某些类型的项目中可能也需要它 ( 如在 JavaScript 中使用 DOM )。 SAX 表现较好，这要依赖于它特定的解析方式－事件驱动。一个 SAX 检测即将到来的 XML 流，但并没有载入到内存 ( 当然当 XML 流被读入时，会有部分文档暂时隐藏在内存中 )。 Statement 和 PreparedStatement 之间的区别 PreparedStatement 是预编译的,对于批量处理可以大大提高效率. 也叫 JDBC 存储过程 使用 Statement 对象。在对数据库只执行一次性存取的时侯，用 Statement 对象进行处理。PreparedStatement 对象的开销比 Statement 大，对于一次性操作并不会带来额外的好处。 Statement 每次执行 sql 语句，相关数据库都要执行 sql 语句的编译，preparedStatement 是预编译得, PreparedStatement 支持批处理 代码片段1: 123String updateString = "UPDATE COFFEES SET SALES = 75 " + "WHERECOF_NAME LIKE ′Colombian′";stmt.executeUpdate(updateString); 代码片段2: 12345PreparedStatement updateSales = con.prepareStatement("UPDATE COFFEES SETSALES = ? WHERE COF_NAME LIKE ? ");updateSales.setInt(1, 75);updateSales.setString(2, "Colombian");updateSales.executeUpdate(); 片断2 和 片断1 的区别在于，后者使用了 PreparedStatement 对象，而前者是普通的 Statement 对象。PreparedStatement 对象不仅包含了 SQL 语句，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需 DBMS 运行 SQL 语句，而不必先编译。当你需要执行 Statement 对象多次的时候，PreparedStatement 对象将会大大降低运行时间，当然也加快了访问数据库的速度。 这种转换也给你带来很大的便利，不必重复 SQL 语句的句法，而只需更改其中变量的值，便可重新执行 SQL 语句。选择 PreparedStatement 对象与否，在于相同句法的 SQL 语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。 执行许多 SQL 语句的 JDBC 程序产生大量的 Statement 和 PreparedStatement 对象。通常认为 PreparedStatement 对象比 Statement 对象更有效,特别是如果带有不同参数的同一 SQL 语句被多次执行的时候。PreparedStatement 对象允许数据库预编译 SQL 语句，这样在随后的运行中可以节省时间并增加代码的可读性。 然而，在 Oracle 环境中，开发人员实际上有更大的灵活性。当使用 Statement 或 PreparedStatement 对象时，Oracle 数据库会缓存 SQL 语句以便以后使用。在一些情况下,由于驱动器自身需要额外的处理和在 Java 应用程序和 Oracle 服务器间增加的网络活动，执行 PreparedStatement 对象实际上会花更长的时间。 然而，除了缓冲的问题之外，至少还有一个更好的原因使我们在企业应用程序中更喜欢使用 PreparedStatement 对象,那就是安全性。传递给 PreparedStatement 对象的参数可以被强制进行类型转换，使开发人员可以确保在插入或查询数据时与底层的数据库格式匹配。 当处理公共 Web 站点上的用户传来的数据的时候，安全性的问题就变得极为重要。传递给 PreparedStatement 的字符串参数会自动被驱动器忽略。最简单的情况下，这就意味着当你的程序试着将字符串 “D’Angelo” 插入到 VARCHAR2 中时，该语句将不会识别第一个 “’”，从而导致悲惨的失败。几乎很少有必要创建你自己的字符串忽略代码。 在Web环境中，有恶意的用户会利用那些设计不完善的、不能正确处理字符串的应用程序。特别是在公共Web站点上,在没有首先通过 PreparedStatement 对象处理的情况下，所有的用户输入都不应该传递给 SQL 语句。此外，在用户有机会修改 SQL 语句的地方，如 HTML 的隐藏区域或一个查询字符串上，SQL 语句都不应该被显示出来。 servlet 生命周期及各个方法参考文章 Servlet 生命周期、工作原理 servlet 中如何自定义 filter参考文章 Servlet Filter JSP 原理参考文章 JSP运行原理及运行过程 JSP 和 Servlet 的区别 JSP 经编译后就变成了 “类 servlet”。 JSP 由 HTML 代码和 JSP 标签构成，更擅长页面显示；Servlet 更擅长流程控制。 JSP 中嵌入 JAVA 代码，而 Servlet 中嵌入 HTML 代码。 JSP的动态 include 和静态 include 动态 include用 jsp:include 动作实现，如 &lt;jsp:include page=&quot;abc.jsp&quot; flush=&quot;true&quot; /&gt;，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。会先解析所要包含的页面，解析后和主页面合并一起显示，即先编译后包含。 静态 include 用 include 伪码实现，不会检查所含文件的变化，适用于包含静态页面，如 &lt;%@ include file=&quot;qq.htm&quot; %&gt;，不会提前解析所要包含的页面，先把要显示的页面包含进来，然后统一编译，即先包含后编译。 Struts 中请求处理过程参考文章 struts2请求过程源码分析 MVC 概念参考文章 MVC的概念 SpringMVC 与 Struts 区别参考文章 同是流行MVC框架，比较Strtus2和SpringMVC的区别 SpringMVC与Struts2区别与比较总结 Hibernate/Ibatis 两者的区别参考文章 Hibernate与 MyBatis的比较 Hibernate 一级和二级缓存参考文章 Hibernate缓存：一级缓存和二级缓存 简述 Hibernate 常见优化策略参考文章 Hibernate性能优化的常用措施 SpringBean 的加载过程(推荐看 Spring 的源码)参考文章 看看Spring的源码（一）——Bean加载过程 SpringBean 的实例化(推荐看 Spring 的源码)参考文章 看看Spring的源码(二)——bean实例化 Spring 如何实现 AOP 和 IOC (推荐看 Spring 的源码)参考文章 Java轻量级业务层框架Spring两大核心IOC和AOP原理 SpringBean 注入方式参考文章 spring四种依赖注入方式 Spring 的事务管理这个主题的参考文章没找到特别好的 Spring事务管理（详解+实例） Spring 事务的传播特性参考文章 Spring事务的传播特性 SpringMVC 原理参考文章 SpringMVC工作原理 SpringMVC 用过哪些注解参考文章 详解Spring MVC 4常用的那些注解 Restful 有几种请求参考文章 RESTful HTTP的实践 Restful 好处 客户-服务器：客户-服务器约束背后的原则是分离关注点。通过分离用户接口和数据存储这两个关注点，改善了用户接口跨多个平台的可移植性；同时通过简化服务器组件，改善了系统的可伸缩性。 无状态：通信在本质上是无状态的，改善了可见性、可靠性、可伸缩性. 缓存：改善了网络效率减少一系列交互的平均延迟时间，来提高效率、可伸缩性和用户可觉察的性能。 统一接口：REST 架构风格区别于其他基于网络的架构风格的核心特征是，它强调组件之间要有一个统一的接口。 Tomcat，Apache，JBoss 的区别ApacheHTTP 服务器( WEB 服务器 )，类似 IIS，可以用于建立虚拟站点，编译处理静态页面，可以支持 SSL 技术，支持多个虚拟主机等功能。 TomcatServlet 容器，用于解析 jsp，Servlet 的 Servlet 容器，是高效，轻量级的容器。缺点是不支持 EJB，只能用于 java 应用。 Jboss应用服务器，运行 EJB 的 J2EE 应用服务器，遵循 J2EE 规范，能够提供更多平台的支持和更多集成功能，如数据库连接，JCA 等，其对 Servlet 的支持是通过集成其他 Servlet 容器来实现的，如 tomcat 和 jetty。 Memcached 和 Redis 的区别 性能对比：由于 Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。 内存使用效率对比：使用简单的 key-value 存储的话，Memcached 的内存利用率更高，而如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 Memcached。 Redis 支持服务器端的数据操作：Redis 相比 Memcached 来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在 Memcached 里，你需要将数据拿到客户端来进行类似的修改再 set 回去。这大大增加了网络 IO 的次数和数据体积。在 Redis 中，这些复杂的操作通常和一般的 GET/SET 一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么 Redis 会是不错的选择。 如何理解分布式锁参考文章 分布式锁1 Java常用技术方案 分布式锁实现机制 你知道的开源协议有哪些常见的开源协议有 GPL、LGPL、BSD、Apache Licence vesion 2.0、MIT，详细内容参考文章 如何选择开源许可协议（一）：了解协议 如何选择开源许可证？ JSON 和 XML 区别XML: 应用广泛，可扩展性强，被广泛应用各种场合； 读取、解析没有JSON快； 可读性强，可描述复杂结构 JSON: 结构简单，都是键值对； 读取、解析速度快，很多语言支持； 传输数据量小，传输速率大大提高； 描述复杂结构能力较弱。 设计模式参考文章 23种设计模式 设计模式的六大原则参考文章 设计模式六大原则 用一个设计模式写一段代码或画出一个设计模式的UML参考文章 23种设计模式 高内聚，低耦合方面的理解参考文章 小菜学设计模式——高内聚、低耦合 深度优先和广度优先算法推荐看书籍复习！可参考文章 深度优先算法，图的遍历 广度优先搜索，图的遍历 深度优先搜索与广度优先搜索 树的深度优先与广度优先遍历 排序算法及对应的时间复杂度和空间复杂度推荐看书籍复习！可参考文章 各种排序算法的分析及java实现 常用排序算法的时间复杂度和空间复杂度 常见排序算法小结 排序算法编码实现参考 各种排序算法的分析及java实现 查找算法参考 七大查找算法 B+ 树参考 B树、B-树、B+树、B*树都是什么 KMP 算法推荐阅读数据复习！参考 【经典算法】——KMP，深入讲解next数组的求解 Hash 算法及常用的 Hash 算法参考 常见hash算法的原理 如何判断一个单链表是否有环参考文章 如何判断一个单链表是否有环？ Java判断链表是否有环的两种实现方法 队列、栈、链表、树、堆、图推荐阅读数据结构复习！ Linux 常用命令参考 Linux常用操作命令 如何查看内存使用情况参考 linux系统下查看CPU、内存负载情况 Linux 下如何进行进程调度推荐阅读书籍复习，参考文章 Linux进程调度原理 Linux进程调度机制 产生死锁的必要条件参考 操作系统：死锁的产生、条件、和解锁 死锁预防参考 操作系统：死锁的产生、条件、和解锁 数据库范式参考 数据库三大范式的理解 数据库事务隔离级别参考 数据库事务隔离级别 数据库连接池的原理参考 谈谈数据库连接池的原理 乐观锁和悲观锁参考 深入理解乐观锁与悲观锁 如何实现不同数据库的数据查询分页参考 不同数据库的分页查询实现方法总结 SQL 注入的原理，如何预防参考 谈谈六个防止SQL注入式攻击的建议 数据库索引的实现( B+ 树介绍、和 B 树、R 树区别 )参考文章 数据库索引的实现原理 由浅入深理解数据库中索引的底层实现 SQL 性能优化参考文章 高手详解SQL性能优化十条经验 Oracle SQL性能优化 数据库索引的优缺点以及什么时候数据库索引失效参考文章 数据库索引的作用和优点缺点以及索引的11中用法 正确高效使用数据库不可不知的索引失效问题 SQL优化避免索引失效 索引失效原因总结 哪些情况下索引会失效？ Redis 的数据类型参考 Redis五种数据类型介绍 OSI 七层模型以及 TCP/IP 四层模型参考文章 OSI七层协议模型和TCP/IP四层模型比较 OSI七层模型及TCP/IP四层模型 TCP/IP四层模型和OSI七层模型的概念 HTTP 和 HTTPS 区别参考 HTTP和HTTPS详解 HTTP与HTTPS的区别 HTTP 报文内容参考文章 HTTP请求报文和HTTP响应报文 http报文详解 HTTP请求报文解剖 get 提交和post 提交的区别参考文章 浅谈HTTP中Get与Post的区别 详解HTTP中GET和POST的区别 get 提交是否有字节限制，如果有是在哪限制的参考 详解HTTP中GET和POST的区别 TCP 的三次握手和四次挥手阅读 TCP的三次握手和四次挥手 Session 和 Cookie的区别参考 cookie 和session 的区别详解 HTTP 请求中 Session 实现原理参考 Session实现原理 redirect 与 forward 区别参考 forward和redirect的区别 TCP 和 UDP 区别参考 TCP和UDP的区别（转） DDos 攻击及预防参考文章 DDoS的攻击原理与防御方法 漫画告诉你什么是DDoS攻击？]]></content>
      <categories>
        <category>Java</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型网站架构技术一览]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[大型网站架构技术一览1. 主要层次：系统性能、可用性、伸缩性、扩展性、安全性2. 网站系统架构层次图 前端架构 安 应用层架构 数据 全 服务层架构 采集 架 存储层架构 与 构 后台架构 监控 数据中心机房架构 1. 前端架构 浏览器优化技术 页面缓存、合并HTTP请求，减少请求次数、使用页面压缩…… 主要就是优化响应页面，加快浏览器页面的加载和显示 CDN（Content Delivery Network ） 内容分发网络，部署在网络运营商机房，通过将静态页面内容分发到利用户最近的CDN服务器， 使用户可以通过最短路径获取内容 动静分离，静态资源独立部署 js、css、images 等文件部署在专门服务器集群，与web应用动态内容服务分离，使用独立域名 图片服务 图片服务使用独立部署的图片服务器集群，使用独立域名 反向代理 部署在网站机房，在应用服务器、静态资源服务器、图片服务器之前，提供页面缓存服务 DNS 域名服务，将域名解析为IP，可实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后 指向CDN服务器 2. 应用架构层（处理网站主要业务逻辑） 开发框架 一个好的开发框架应该使系统内部模块间耦合性尽可能降低，使开发人员可以各司其职。 同时还应 配置一些安全策略，预防Web应用攻击 页面渲染 将分别开发的动态内容和静态页面模板整合起来，组合成最终显示给用户的完整页面 负载均衡 将多台应用服务器组成一个集群，通过负载均衡技术将用户请求分发到不同的服务器，以应对高并发 负载压力 Session管理 应用服务器通常是被设计为无状态，不保存用户请求上下文信息，但网站业务逻辑通常需要保持用户会话 信息，所以需要专门的机制来管理Session，使集群内甚至跨集群的应用服务器可以共享Session 动态页面静态化 对于访问量特别大而更新又不是很频繁的动态页面，可以将其静态化，利用静态页面的优化手段加速用户 访问 业务拆分 将复杂业务进行拆分，形成多个模块较小的产品，独立开发、部署、维护，降低系统耦合度，同是也有利于 数据库拆分 虚拟化服务器 将一台物理服务器虚拟化为多台虚拟服务器，对于并发访问较低的业务，更容易用较少的资源构建高可用的应用服务器集群 3. 服务层架构（提供基础服务，供应用层调用） 分布式消息 利用消息队列，实现业务和业务、业务和服务之间的异步消息发送及低耦合的业务关系 分布式服务 提供高性能、低耦合、易复用、易管理的分布式服务，在网站实现面向服务架构（SOA） 分布式缓存 通过可伸缩的服务器集群提供大规模热点数据的缓存服务，是网站性能优化的重要手段 分布式配置 分布式配置在系统训行乞提供配置动态推送服务，将配置修改事实推送到应用系统，无需重启 服务器 4. 存储层架构（提供数据、文件的持久化访问与管理） 分布式文件 网站在线业务需要存储的文件大部分是图片、网页、视频等比较小的文件，但是数量却非常庞大， 需要伸缩性比较好的分布式文件系统 关系数据库 关系数据库对集群伸缩性的支持比较差，通过在应用的数据访问层增加数据库访问路由功能， 根具业务配置将数据库访问路由到不同的物理数据库上，实现关系数据库分布式访问 NoSQL 数据库 内存管理、数据模型、集群分布式管理 HBase 数据同步 多个数据中心之间数据要进行同步，在实践中，为了减轻数据库的压力，将数据库的事务日志 （或NoSQL的写操作Log）同步到其他数据中心，根据Log进行数据重演，实现数据同步，以减少 大量数据进行同步造成的资源浪费 5. 后台架构（非实时数据的分析） 搜索引擎 后台系统创建定时任务，定时进行数据的增量更新、全量更新、构建索引等 数据仓库 根据离线数据，提供数据分析与数据挖掘 推荐系统 社交网站及购物网站通过挖掘人与人之间的关系，人和商品之间的关系，发掘潜在的人间关系 和购物兴趣，为用户提供个性化推荐服务 6. 数据采集与监控 浏览器数据采集 通过网站页面嵌入js脚本采集用户浏览器环境与操作记录，分析用户行为 服务器业务数据采集 采集在服务器端记录的用户请求操作日志 采集应用程序运行期业务数据，比如待处理消息数目等 服务器性能数据采集 采集服务器性能数据：系统负载、内存利用率、网卡流量等 系统监控 将前述采集的数据以图表的方式展示，以便运营和运维人员监控网站运行状况。 再进一步应该做到 根据采集的数据进行自动化运维，自动处理系统异常状况，实现自动化控制 系统报警 若采集来的数据超过预设的正常情况的阈值，比如系统负载过高，就通过邮件、短信、语音电话等方式 发出报警信号、等待工程师进行干预 7. 安全架构（保护网站免遭攻击及敏感信息泄露） Web攻击 以HTTP请求的方式发起的攻击，危害最大的就是XSS与SQL注入攻击。但是只要措施得当，这两种攻击 方式都比较容易防范 数据保护 敏感信息加密传输与存储，保护网站和用户资产 8. 数据中心机房架构（数据中心功耗问题） 机柜架构 机柜大小、网线布局、指示灯规格、不间断电源、电源规格等 服务器架构 根据网站应用需求，定制硬盘、内存、甚至CPU，同是去除不必要的外设接口（显示器输出接口、 键盘、鼠标数据接口），并使空间结构利与散热]]></content>
      <categories>
        <category>网站架构</category>
      </categories>
      <tags>
        <tag>网站架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25个经典的Spring面试问答]]></title>
    <url>%2F2019%2F01%2F03%2F25%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84Spring%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[25个经典的Spring面试问答1、什么是Spring框架？Spring框架有哪些主要模块？Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。 Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 2、使用Spring框架能带来哪些好处？下面列举了一些使用Spring框架带来的主要好处： 1、Dependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。 2、与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。 3、Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。 4、Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。 5、要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。 5、Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。 6、Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。 3、什么是控制反转(IOC)？什么是依赖注入？1、控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的。在使用控制反转的情况下，业务逻辑的流程是由对象关系图来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。 2、控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效的作用。 3、依赖注入是在编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？ 4、在Java中依然注入有以下三种实现方式： 1.构造器注入 2.Setter方法注入 3.接口注入 4、请解释下Spring框架中的IoC？Spring中的 org.springframework.beans 包和 org.springframework.context包构成了Spring框架IoC容器的基础。 BeanFactory 接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContex接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易集成，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。 5、BeanFactory和ApplicationContext有什么区别？BeanFactory 可以理解为含有bean集合的工厂类。BeanFactory 包含了种bean的定义，以便在接收到客户端请求时将对应的bean实例化。 BeanFactory还能在实例化对象的时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。 从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。 1.提供了支持国际化的文本消息 2.统一的资源文件读取方式 3.已在监听器中注册的bean的事件 以下是三种较常见的 ApplicationContext 实现方式： 1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。 ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”); 2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。 ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”); 3、XmlWebApplicationContext：由Web应用的XML文件读取上下文。 6、Spring有几种配置方式？将Spring配置到应用开发中有以下三种方式： 1.基于XML的配置 2.基于注解的配置 3.基于Java的配置 7、如何用基于XML配置的方式配置Spring？在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用开头，然后一系列的bean定义和专门的应用配置选项组成。 SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式） Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。 123456&lt;beans&gt; &lt;!-- JSON Support --&gt; &lt;bean name="viewResolver" class="org.springframework.web.servlet.view.BeanNameViewResolver"/&gt; &lt;bean name="jsonTemplate" class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/&gt; &lt;bean id="restTemplate" class="org.springframework.web.client.RestTemplate"/&gt;&lt;/beans&gt; 下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。 1234567891011121314&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 8、如何用基于Java配置的方式配置Spring？Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。 最简单的@Configuration 声明类请参考下面的代码： 12345678@Configurationpublic class AppConfig&#123; @Bean public MyService myService() &#123; return new MyServiceImpl(); &#125;&#125; 对于上面的@Beans配置文件相同的XML配置文件如下： 123&lt;beans&gt; &lt;bean id="myService" class="com.howtodoinjava.services.MyServiceImpl"/&gt;&lt;/beans&gt; 上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化 12345public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; 要使用组件组建扫描，仅需用@Configuration进行注解即可： 12345@Configuration@ComponentScan(basePackages = "com.howtodoinjava")public class AppConfig &#123; ...&#125; 在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。 如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置Spring的Servlet监听器ContrextLoaderListener或者Spring MVC的DispatcherServlet。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;web-app&gt; &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;context-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Configuration locations must consist of one or more comma- or space-delimited fully-qualified @Configuration classes. Fully-qualified packages may also be specified for component-scanning --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.AppConfig&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext instead of the default XmlWebApplicationContext --&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt; org.springframework.web.context.support.AnnotationConfigWebApplicationContext &lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- Again, config locations must consist of one or more comma- or space-delimited and fully-qualified @Configuration classes --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;com.howtodoinjava.web.MvcConfig&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 9、怎样用注解的方式配置Spring？Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。 注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置。 1234&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt;&lt;/beans&gt; 在 标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。 下面是几种比较重要的注解类型： 1.@Required：该注解应用于设值方法。 2.@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 3.@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。 4.JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。 10、请解释Spring Bean的生命周期？Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。 Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。 1.初始化之后调用的回调方法。 2.销毁之前调用的回调方法。 Spring框架提供了以下四种方式来管理bean的生命周期事件： 1、InitializingBean和DisposableBean回调接口 2、针对特殊行为的其他Aware接口 3、Bean配置文件中的Custom init()方法和destroy()方法 4、@PostConstruct和@PreDestroy注解方式 使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下： 1234&lt;beans&gt; &lt;bean id="demoBean" class="com.howtodoinjava.task.DemoBean" init-method="customInit" destroy-method="customDestroy"&gt;&lt;/bean&gt;&lt;/beans&gt; 11、Spring Bean的作用域之间有什么区别？Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下： 1.singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。 2.prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。 3.request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 4.Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 5.global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。 全局作用域与Servlet中的session作用域效果相同。 12、什么是Spring inner beans？在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。 比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建一个Person的实例，然后在Customer内部使用。 12345678910111213141516171819202122232425public class Customer&#123; private Person person; //Setters and Getters&#125;public class Person&#123; private String name; private String address; private int age; //Setters and Getters&#125;内部bean的声明方式如下：&lt;bean id="CustomerBean" class="com.howtodoinjava.common.Customer"&gt; &lt;property name="person"&gt; &lt;!-- This is inner bean --&gt; &lt;bean class="com.howtodoinjava.common.Person"&gt; &lt;property name="name" value="lokesh" /&gt; &lt;property name="address" value="India" /&gt; &lt;property name="age" value="34" /&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 13、Spring框架中的单例Beans是线程安全的么？Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。 最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。 14、请举例说明如何在Spring中注入一个Java Collection？Spring提供了以下四种集合类的配置元素： 1、 : 该标签用来装配可重复的list值。 2、 : 该标签用来装配没有重复的set值。 3、: 该标签可用来注入键和值可以为任何类型的键值对。 4、 : 该标签支持注入键和值都是字符串类型的键值对。 下面看一下具体的例子： 123456789101112131415161718192021222324252627282930313233343536373839&lt;beans&gt; &lt;!-- Definition for javaCollection --&gt; &lt;bean id="javaCollection" class="com.howtodoinjava.JavaCollection"&gt; &lt;!-- java.util.List --&gt; &lt;property name="customList"&gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- java.util.Set --&gt; &lt;property name="customSet"&gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;UK&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- java.util.Map --&gt; &lt;property name="customMap"&gt; &lt;map&gt; &lt;entry key="1" value="INDIA"/&gt; &lt;entry key="2" value="Pakistan"/&gt; &lt;entry key="3" value="USA"/&gt; &lt;entry key="4" value="UK"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- java.util.Properties --&gt; &lt;property name="customProperies"&gt; &lt;props&gt; &lt;prop key="admin"&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key="support"&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 15、如何向Spring Bean中注入一个Java.util.Properties？第一种方法是使用如下面代码所示的 标签： 123456789&lt;bean id="adminUser" class="com.howtodoinjava.common.Customer"&gt; &lt;!-- java.util.Properties --&gt; &lt;property name="emails"&gt; &lt;props&gt; &lt;prop key="admin"&gt;admin@nospam.com&lt;/prop&gt; &lt;prop key="support"&gt;support@nospam.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。 16、请解释Spring Bean的自动装配？在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring容器还可以自动装配合作关系bean之间的关联关系。这意味着Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。 下面的XML配置文件表明了如何根据名称将一个bean设置为自动装配： 12&lt;bean id="employeeDAO" class="com.howtodoinjava.EmployeeDAOImpl" autowire="byName" /&gt;1 除了bean配置文件中提供的自动装配模式，还可以使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在按照如下的配置方式在Spring配置文件进行配置才可以使用。 1&lt;context:annotation-config /&gt; 也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 达到相同的效果。 1&lt;bean class ="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/&gt; 配置好以后就可以使用@Autowired来标注了。 1234@Autowiredpublic EmployeeDAOImpl ( EmployeeManager manager ) &#123; this.manager = manager;&#125; 17、请解释自动装配模式的区别？在Spring框架中共有5种自动装配，让我们逐一分析。 1.no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。 2.byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 3.byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 4.constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 5.autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。 18、如何开启基于注解的自动装配？要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现： 1、引入配置文件中的下引入 123&lt;beans&gt; &lt;context:annotation-config /&gt;&lt;/beans&gt; 2、在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor 123&lt;beans&gt; &lt;bean class="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/&gt;&lt;/beans&gt; 19、请举例解释@Required annotation？在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在中设置“dependency-check”来解决这个问题。 在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。 需要用如下的方式使用来标明bean的设值方法。 123456789101112public class EmployeeFactoryBean extends AbstractFactoryBean&lt;Object&gt;&#123; private String designation; public String getDesignation() &#123; return designation; &#125; @Required public void setDesignation(String designation) &#123; this.designation = designation; &#125; //more code here&#125; RequiredAnnotationBeanPostProcessor是Spring中的后置处理用来验证被@Required 注解的bean属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso来验证bean属性之前，首先要在IoC容器中对其进行注册： 1&lt;bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor" /&gt; 但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个BeanInitializationException 异常。 20、请举例解释@Autowired注解？@Autowired注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired注解可以像@Required注解、构造器一样被用于在bean的设值方法上自动装配bean的属性，一个参数或者带有任意名称或带有多个参数的方法。 比如，可以在设值方法上使用@Autowired注解来替代配置文件中的 元素。当Spring容器在setter方法上找到@Autowired注解时，会尝试用byType 自动装配。 当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个bean时将会被自动装配，即便在配置文件中使用 元素。 1234567891011public class TextEditor &#123; private SpellChecker spellChecker; @Autowired public TextEditor(SpellChecker spellChecker)&#123; System.out.println("Inside TextEditor constructor." ); this.spellChecker = spellChecker; &#125; public void spellCheck()&#123; spellChecker.checkSpelling(); &#125;&#125; 下面是没有构造参数的配置方式： 123456789&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- Definition for textEditor bean without constructor-arg --&gt; &lt;bean id="textEditor" class="com.howtodoinjava.TextEditor"&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id="spellChecker" class="com.howtodoinjava.SpellChecker"&gt; &lt;/bean&gt;&lt;/beans&gt; 21、请举例说明@Qualifier注解？@Qualifier注解意味着可以在被标注bean的字段上可以自动装配。Qualifier注解可以用来取消Spring不能取消的bean应用。 下面的示例将会在Customer的person属性中自动装配person的值。 12345public class Customer&#123; @Autowired private Person person;&#125; 下面我们要在配置文件中来配置Person类。 1234567&lt;bean id="customer" class="com.howtodoinjava.common.Customer" /&gt;&lt;bean id="personA" class="com.howtodoinjava.common.Person" &gt; &lt;property name="name" value="lokesh" /&gt;&lt;/bean&gt;&lt;bean id="personB" class="com.howtodoinjava.common.Person" &gt; &lt;property name="name" value="alex" /&gt;&lt;/bean&gt; Spring会知道要自动装配哪个person bean么？不会的，但是运行上面的示例时，会抛出下面的异常： Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No unique bean of type [com.howtodoinjava.common.Person] is defined: expected single matching bean but found 2: [personA, personB] 要解决上面的问题，需要使用 @Quanlifier注解来告诉Spring容器要装配哪个bean： 123456public class Customer&#123; @Autowired @Qualifier("personA") private Person person;&#125; 22、构造方法注入和设值注入有什么区别？请注意以下明显的区别： 1.在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。 2.设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。 3.在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。 4.在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。 23、Spring框架中有哪些不同类型的事件？Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。 我们可以创建bean用来监听在ApplicationContext 中发布的事件。ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。 12345678public class AllApplicationEventListener implements ApplicationListener &lt; ApplicationEvent &gt;&#123; @Override public void onApplicationEvent(ApplicationEvent applicationEvent) &#123; //process event &#125;&#125; Spring 提供了以下5中标准的事件： 1.上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。 2.上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。 3.上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。 4.上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。 5.请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。 除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。 12345678public class CustomApplicationEvent extends ApplicationEvent&#123; public CustomApplicationEvent ( Object source, final String msg ) &#123; super(source); System.out.println("Created a Custom event"); &#125;&#125; 为了监听这个事件，还需要创建一个监听器： 1234567public class CustomEventListener implements ApplicationListener &lt; CustomApplicationEvent &gt;&#123; @Override public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123; //handle event &#125;&#125; 之后通过applicationContext接口的publishEvent()方法来发布自定义事件。 CustomApplicationEvent customEvent = new CustomApplicationEvent(applicationContext, “Test message”); applicationContext.publishEvent(customEvent); 24、FileSystemResource和ClassPathResource有何区别？在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。 如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。 简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。 25、Spring 框架中都用到了哪些设计模式？Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的： 1、代理模式—在AOP和remoting中被用的比较多。 2、单例模式—在spring配置文件中定义的bean默认为单例模式。 3、模板方法—用来解决代码重复的问题。 4、比如. RestTemplate, JmsTemplate, JpaTemplate。 5、前端控制器—Srping提供了DispatcherServlet来对请求进行分发。 6、视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。 7、依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。 8、工厂模式—BeanFactory用来创建对象的实例。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构算法]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据结构算法总结 [TOC] 顺序表12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;# define maxSize 100template &lt;class DataType&gt;class SeqList&#123; private: DataType data[maxSize]; int length; public: SeqList(DataType a[],int n)&#123; if(n&gt;maxSize)throw "exception"; for(int i=0;i&lt;n;i++)&#123; data[i]=a[i]; &#125; length=n; &#125; bool Insert(int i,DataType x)&#123; if(i&lt;1||i&gt;length+1)return false; if(length&gt;=maxSize)return false; for(int j=length;j&gt;=i;j--) data[j]=data[j-1]; data[i-1]=x; length++; return true; &#125; DataType Delete(int i)&#123;//删除i位置上的元素 if(i&lt;1||i&gt;length+1)return false; DataType x=data[i-1]; for(int j=i;j&lt;length;j++) data[j-1]=data[j]; length--; return true; &#125; int Local(DataType x)&#123;//查找X for(int i=0;i&lt;length;i++)&#123; if(data[i]==x)return i+1; &#125; return 0; &#125; DataType Get(int i)&#123; if(i&lt;1||i&gt;length)throw "exception"; else return data[i-1]; &#125;&#125;;int main()&#123; &#125; 单链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;using namespace std;# define maxSize 100 template &lt;class DT&gt;struct Node&#123; DT data; Node&lt;DT&gt; *next;&#125;;template &lt;class DT&gt;class LinkList&#123; private: Node&lt;DT&gt; *first; public: LinkList()&#123; first=new Node&lt;DT&gt;; first-&gt;next=NULL; &#125; LinkList_Head(DT a[],int n)&#123; first=new Node&lt;DT&gt;; first-&gt;next=NULL; for(int i=0;i&lt;n;i++)&#123; Node&lt;DT&gt; *s=new Node&lt;DT&gt;; s-&gt;data=a[i]; s-&gt;next=first-&gt;next; first-&gt;next=s; &#125; &#125; LinkList_Tail(DT a[],int n)&#123; first=new Node&lt;DT&gt;; Node&lt;DT&gt; *r=first; Node&lt;DT&gt; *s=new Node&lt;DT&gt;; for(int i=0;i&lt;n;i++)&#123; s-&gt;data=a[i]; r-&gt;next=s; r=s; &#125; r-&gt;next=NULL; &#125; int Length()&#123; Node&lt;DT&gt; *p=first-&gt;next; int count=0; while(p!=NULL)&#123; p=p-&gt;next; count++; &#125; return count; &#125; DT Get(int i)&#123; Node&lt;DT&gt; *p=first-&gt;next; int count=1; while(p!=NULL&amp;&amp;count&lt;i)&#123; p=p-&gt;next; count++; &#125; return p-&gt;data; &#125; int Locate(DT x)&#123; Node&lt;DT&gt; *p=first-&gt;next; int count=1; while(p!=NULL)&#123; if(p-&gt;data==x)return count; p=p-&gt;next; count++; &#125; return 0; &#125; void Insert(int i,DT x)&#123; Node&lt;DT&gt; *p=first; int count=0; while(p!=NULL&amp;&amp;count&lt;i-1)&#123; p=p-&gt;next; count++; &#125; Node&lt;DT&gt; *s=new Node&lt;DT&gt;; s-&gt;data=x; s-&gt;next=p-&gt;next; p-&gt;next=s; &#125; DT Delete(int i)&#123; Node&lt;DT&gt; *p=first; count=0; while(p!=NULL&amp;&amp;count&lt;i-1)&#123; p=p-&gt;next; count++; &#125; if(p==NULL||p-&gt;next==NULL)&#123; throw "位置"; &#125;else&#123; Node&lt;DT&gt; *q=p-&gt;next; DT x=q-&gt;data; p-&gt;next=q-&gt;next; delete q; return x; &#125; &#125; &#125;; int main()&#123; cout&lt;&lt;1&lt;&lt;endl;&#125; 顺序栈12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;# define StackSize 100 template &lt;class DT&gt;class SeqStack&#123; private: DT data[StackSize]; int top; public: SeqStack()&#123;top=-1;&#125; void Push(DT x)&#123; if(top==StackSize-1)throw "溢出"; data[++top]=x; &#125; DT Pop()&#123; if(top==-1)throw "溢出"; DT x=data[top--]; return x; &#125; DT GetTop()&#123; if(top!=-1) return data[top]; &#125;&#125;;int main()&#123; &#125; 链栈1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;# define maxSize 100 template &lt;class DT&gt;struct Node&#123; DT data; Node&lt;DT&gt; *next;&#125;;template &lt;class DT&gt;class LinkStack&#123; private: Node&lt;DT&gt; *top; public: LinkStack()&#123;top=NULL;&#125; void Push(DT x)&#123; Node&lt;DT&gt; *s=new Node&lt;DT&gt;; s-&gt;data=x; s-&gt;next=top; top=s; &#125; DT Pop()&#123; if(top==NULL)throw "下溢"; DT x=top-&gt;data; Node&lt;DT&gt; *p=top; top=top-&gt;next; delete p; return x; &#125; DT GetTop()&#123; if(top!=NULL) return top-&gt;data; &#125;&#125;;int main()&#123; &#125; 顺序共享栈1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;# define StackSize 100 template &lt;class DT&gt;class BothStack&#123; private: DT data[StackSize]; int top1; int top2; public: SeqStack()&#123;top=-1;&#125; void Push(int i,DT x)&#123; if(top1==top2-1)throw "溢出"; if(i==1)data[++top1]=x; if(i==2)data[--top2]=x; &#125; DT Pop(int i)&#123; if(i==1)&#123; if(top1==-1)throw "下溢"; return data[top1--]; &#125; if(i==2)&#123; if(top2==StackSize)throw "下溢"; return data[top2++]; &#125; &#125; &#125;;int main()&#123; &#125; 循环队列1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int QueueSize=100;template &lt;class DT&gt;class CirQueue&#123; private: DT data[QueueSize]; int front,rear; public: CirQueue()&#123; front=rear=QueueSize-1; &#125; void EnQueue(DT x)&#123; if((rear+1)%QueueSize==front)throw "上溢"; rear=(rear+1)%QueueSize; data[rear]=x; &#125; DT DeQueue()&#123; if(rear=front)throw "下溢"; front=(front+1)%QueueSize; return data[front]; &#125; DT GetQueue()&#123; if(rear=front)throw "下溢"; int i=(front+1)%QueueSize; return data[i]; &#125; int Empty()&#123; front==rear?return 1:retuen 0; &#125;&#125;; int main()&#123; &#125; 链队列1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;template &lt;class DT&gt;struct Node&#123; DT data; Node *next;&#125;;template &lt;class DT&gt;class LinkQueue&#123; private: Node&lt;DT&gt; *front,*rear; public: LinkQueue()&#123; Node&lt;DT&gt; *s=new Node&lt;DT&gt;; s-&gt;next=NULL; front=rear=s; &#125; void EnQueue(DT x)&#123; Node&lt;DT&gt; *s=new Node&lt;DT&gt;; s-&gt;data=x; s-&gt;next=NULL; rear-&gt;next=s; rear=s; &#125; DT DeQueue()&#123; if(rear==front) throw "下溢"; Node&lt;DT&gt; *p=front-&gt;next; DT x=p-&gt;data; front-&gt;next=p-&gt;next; if(p-&gt;next==NULL)rear=front; delete p; return x; &#125; int Empty()&#123; if(front==rear)return 1; return 0; &#125;&#125;;int main()&#123; &#125; KMP123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;String&gt;using namespace std;void getnext(string T,int next[])&#123;//T[0]，next[0] 不用 int i=1,j=0; next[1]=0; while(i&lt;=T[0])&#123; if(j==0||T[i]==T[j])&#123; i++; j++; next[i]=j; &#125;else&#123; j=next[j]; &#125; &#125;&#125;int KMP(string S,string T,int next[])&#123;//s为主串，T为模式串，每个数组的0位置不用，用来存数组大小 int i=1,j=1; while(i&lt;=S[0]&amp;&amp;j&lt;=T[0])&#123; if(j==0||S[i]==T[j])&#123; i++; j++; &#125;else&#123; j=next[j]; &#125; &#125; if(j&gt;T[0])return i-T[0]; else return 0; &#125;int main()&#123; char cnt; string S="abcabaaabaabcac"; cnt=15; S=cnt+S; string T="abaabcac";// char T[10]=&#123;8,'a','b','a','a','b','c','a','c'&#125;; cnt=8; T=cnt+T; int next[9];next[0]=-1; getnext(T,next); cout&lt;&lt;KMP(S,T,next);&#125; 二叉排序树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;struct Node&#123; int data; Node *lchild; Node *rchild; &#125;;void InsertBST(Node *root,Node *s)&#123; if(root==NULL)root=s; else if(s-&gt;data&lt;root-&gt;data)InsertBST(root-&gt;lchild,s); else InsertBST(root-&gt;rchild,s); &#125;Node *BiSortTree(int a[],int n)&#123; Node *root=NULL; for(int i=0;i&lt;n;i++)&#123; Node *s=new Node; s-&gt;data=a[i]; s-&gt;lchild=s-&gt;rchild=NULL;//构造好要插入的节点，执行插入操作 InsertBST(root,s); &#125;&#125;//此删除假设的是删除节点是父节点的左孩子情况void DeleteBST(Node *p,Node *f)&#123;//待删结点p，双亲结点f if(p-&gt;lchild==NULL&amp;&amp;p-&gt;rchild==NULL)&#123; f-&gt;lchild=NULL; delete p; &#125;else if(p-&gt;rchild==NULL)&#123;//p只有左子树 f-&gt;lchild==p-&gt;rchild; delete p; &#125;else if(p-&gt;lchild==NULL)&#123;//p只有右子树 f-&gt;lchild=p-&gt;rchild; delete p; &#125;else&#123; Node *par=p; Node *s=p-&gt;lchild; while(s-&gt;lchild!=NULL)&#123; par=s; s=s-&gt;lchild; &#125; p-&gt;data=s-&gt;data; if(par==p)par-&gt;rchild=s-&gt;rchild; else par-&gt;lchild=s-&gt;rchild; delete s; &#125;&#125;int main()&#123; &#125; 图邻接矩阵广搜深搜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MaxSize=10;int visited[MaxSize]=&#123;0&#125;;template &lt;class DT&gt;class MGraph&#123; private: DT vertex[MaxSize];//存放顶点 int arc[MaxSize][MaxSize];//存放边 int vertexNum,arcNum; public: MGraph(DT a[],int n,int e)&#123;//n个顶点，e条边 vertexNum=n;arcNum=e; for(int i=0;i&lt;vertexNum;i++)vertex[i]=a[i]; for(int i=0;i&lt;vertexNum;i++) for(int j=0;j&lt;vertexNum;j++) arc[i][j]=0; for(int k=0;k&lt;arcNum;k++)&#123;int i,j; cin&gt;&gt;i&gt;&gt;j; arc[i][j]=arc[j][i]=1; &#125; &#125; void DFSTraverse(int v)&#123;//初始遍历结点 cout&lt;&lt;vertex[v]; visited[v]=1; for(int i=0;i&lt;vertexNum;i++) if(arc[v][i]==1&amp;&amp;visited[i]==0) DFSTraverse(i); &#125; void BFSTraverse(int v)&#123; queue&lt;int&gt; q; int front,rear;front=rear=-1; cout&lt;&lt;vertex[v];visited[v]=1; q.push(v); while(q.empty()!=true)&#123; v=q.pop(); for(int i=0;i&lt;vertexNum;i++)&#123; if(arc[v][i]==1&amp;&amp;visited[i]==0) cout&lt;&lt;vertex[i]; visited[i]=1; q.push(i); &#125; &#125; &#125;&#125;; int main()&#123; &#125; 图邻接表广搜深搜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MaxSize=10;int visited[MaxSize]=&#123;0&#125;;struct Node&#123;//邻接点 int data; Node *next; &#125;;template &lt;class DT&gt;struct VertexNode&#123;//顶点表结点 DT vertex; Node *firstedge;&#125;;template&lt;class DT&gt;class ALGraph&#123; private: VertexNode&lt;DT&gt; adjlist[MaxSize]; int vertexNum,arcNum; public:e ALGraph(DT a[],int n,int e)&#123;//n顶点，e条边 vertexNum=n;arcNum=e; for(int i=0;i&lt;vertexNum;i++)&#123; adjlist[i].vertex=a[i]; adjlist[i].firstedge=NULL; &#125; for(int k=0;k&lt;arcNum;k++)&#123; int i,j; cin&gt;&gt;i&gt;&gt;j; Node *s=new Node; s-&gt;data=j; s-&gt;next=adjlist[i].firstedge;//头插 adjlist[i].fistedge=s; &#125; &#125; void DFSTraverse(int v)&#123; cout&lt;&lt;adjlist[v].vertex;visited[v]=1; Node *p=adjlist[v].firstedge; while(p!=NULL)&#123; int i=p-&gt;data; if(visited[i]==0)DFSTraverse(i); p=p-&gt;next; &#125; &#125; void BFSTraverse(int v)&#123; queue&lt;int&gt; Q; cout&lt;&lt;adjlist[v].vertex; visited[v]=1; Q.push(v); while(Q.empty()!=true)&#123; v=Q.pop(); Node *p=adjlist[v].firstedge; while(p!=NULL)&#123; int i=p-&gt;data; if(visited[i]==0)&#123; cout&lt;&lt;adjlist[i].vertex; visited[i]=1; Q.push(i); &#125; p=p-&gt;next; &#125; &#125; &#125; &#125;; int main()&#123; &#125; 排序插入排序优点：实现简单，数据量少时效率高 如果输入序列已经预排序，时间复杂度为O(n+d),d是反转的次数。 算法运行效率优于选择排序冒泡排序即使是最坏的情况三个算法时间复杂度均为O($n^2 $) 能在接收序列的同时进行排序 123456789void InsertSort(int r[],int n)&#123; for(int i=2;i&lt;n;i++)&#123; r[0]=r[i];//r[0]用于暂存要移动的元素 for(int j=i-1;r[0]&lt;r[j];j--)&#123;//往前找插入位置 r[j+1]=r[j];//元素后移 &#125; r[j+1]=r[0];//插入 &#125;&#125; 冒泡排序按照改进的算法，对于一个已经有序的数组，算法完成第一次外层循环后就会返回。实际上只发生了 N - 1次比较，所以最好的情况下，该算法复杂度是O(n)。 123456789101112131415void BubbleSort()&#123; int [] array=&#123;1,5,3,2,6,7,9,13,54,20&#125;; for(int i=0;i&lt;array.length-1;i++)&#123; //每一轮比较的次数为N-1-i; for(int j=0;j&lt;array.length-1-i;j++)&#123; //比较相邻的两个数,小靠前 if(array[j]&gt;array[j+1])&#123; //两个数做交换.通过设置临时变量 int temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; &#125; &#125; &#125;&#125; 123456789101112131415161718void BubbleSortImproved()&#123; int [] array=&#123;1,5,3,2,6,7,9,13,54,20&#125;; boolean swapped=true; for(int i=0;i&lt;array.length-1&amp;&amp;swapped;i++)&#123; swapped=false; //每一轮比较的次数为N-1-i; for(int j=0;j&lt;array.length-1-i;j++)&#123; //比较相邻的两个数,小靠前 if(array[j]&gt;array[j+1])&#123; //两个数做交换.通过设置临时变量 int temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; swapped=true; &#125; &#125; &#125;&#125; 选择排序优点：容易实现，原地排序不需要额外的存储空间 缺点：扩展性差 12345678910111213141516171819void SelectSort()&#123; int [] array=&#123;1,5,3,2,6,7,9,13,54,20&#125;; int min=0;//保存最元素值的下标 for(int i=0;i&lt;array.length-1;i++)&#123; min=i; //查找最小数在数组中的下标 for(int j=i+1;j&lt;array.length;j++)&#123; if(array[min]&gt;array[j])&#123; min=j;//保存最小数的下标 &#125; &#125; //如果第i个最小的数位置不在i上,则进行交换 if(i!=min)&#123; int temp=array[i]; array[i]=array[min]; array[min]=temp; &#125; &#125;&#125; 希尔排序希尔排序是基于直接插入排序的，直接插入排序在元素较少和元素基本有序时效率是不错的，但随着元素增多和有序性破坏，效率会下降的很明显。希尔排序通过分组实现跳跃式移动，保证待排序序列基本有序后再排序，就能提高效率。 1234567891011void ShellSort(int r[],int n)&#123; for(int d=n/2;d&gt;1;d=d/2)&#123; for(int i=d+1;i&lt;n;i++)&#123; r[0]=r[i];//把元素存起来 for(int j=i-d;j&gt;0&amp;&amp;r[0]&lt;r[j];j=j-d)&#123;//往前以步长d查找元素 r[j+d]=r[j];//元素后移 &#125; r[j+d]=r[0];//插入 &#125; &#125;&#125; 快速排序快速排序的思想是分割，是分治算法技术的一个实例。确保一个元素左边的元素都小于这个元素，右边的元素都大于这个元素，然后对这两部分分别继续进行分割，从而达到排序的效果。 123456789101112131415161718192021222324252627void Quicksort(int[] a,int low,int high)&#123; int temp; if(low&lt;high)&#123; temp = partition(a,low,high); Quicksort(a,low,temp-1); Quicksort(a,temp+1,high); &#125;&#125;int partition(int[] a,int low,int high)&#123; int i=low; int j=high; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;a[i]&lt;=r[j]) j--;//右侧扫描 if(i&lt;j)&#123;swap(a,i,j);i++;&#125;//小记录置前 while(i&lt;j&amp;&amp;a[i]&lt;=r[j]) i++;//左侧扫描 if(i&lt;j)&#123;swap(a,i,j);j--&#125;//大记录置后 &#125; return low;&#125;void swap(int[] a,int low,int high)&#123; if(low&lt;high)&#123; int temp=a[low]; a[low]=a[high]; a[high]=a[low]; &#125;&#125; 堆排序基于比较的排序，属于选择排序，优点是最坏的情况下O($ n \log n $) 基本思想：首先将待排序的记录序列构造成一个堆，此时，选出了堆中所有记录的最大者，然后将它从堆中移走，并将剩余的记录再调整成堆，这样又找出了次小的记录，以此类推，直到堆中只有一个记录。 1234567891011121314151617181920212223 void HeapSort(int[] a,int n)&#123; for(int i=n/2; i&gt;=1; i--)&#123; heapAdjust(a,i,n);//从最后一个有子节点的节点开始依次往前调整对应节点来生成大顶堆 &#125; for(int i=1; i&lt;n; i++)&#123; swap(a,1,n-i-1);//交换堆顶元素与未排序堆最后一个元素 heapAdjust(a,1,n-i);//根据调整节点重新生成大顶堆 &#125;&#125; void heapAdjust(int r[], int k, int m )&#123; //要筛选结点的编号为k，堆中最后一个结点的编号为m int i=k; int j=2*i;//到达下一层的左孩子 while (j&lt;=m)&#123; //筛选还没有进行到叶子 if (j&lt;m &amp;&amp; r[j]&lt;r[j+1]) j++; //左右孩子中取较大者 if (r[i]&gt;r[j]) break; else &#123; swap(r,i,j); i=j; j=2*i; &#125; &#125; &#125; 归并排序归并排序的主要操作是归并，其主要思想是：将若干有序序列逐步归并，最终得到一个有序序列。 123456789101112131415161718192021222324252627282930313233343536373839int[] sort(int[] o,int m,int n)&#123; int mid; int[] result = new int[o.length]; if(o.length == 1|| m==n)&#123; result[0] = o[0]; &#125;else&#123; mid = (m+n)/2; int[] temp1 = new int[mid-m+1]; int[] temp2 = new int[o.length-mid+m-1]; System.arraycopy(o,0,temp1,0,mid-m+1); System.arraycopy(o,mid-m+1,temp2,0,o.length-mid+m-1); int[] result1 = sort(temp1,m,mid); int[] result2 = sort(temp2,mid+1,n); result = Merge(result1,result2); &#125; return result;&#125;int[] Merge(int[] i,int[] j)&#123; int m=0,n=0,k=0; int[] result = new int[i.length+j.length]; for(; m&lt;i.length&amp;&amp;n&lt;j.length; k++)&#123; if(i[m]&lt;j[n])&#123; result[k] = i[m++]; &#125;else&#123; result[k] = j[n++]; &#125; &#125; if(m&lt;i.length)&#123; while(m&lt;i.length)&#123; result[k++] = i[m++]; &#125; &#125; if(n&lt;j.length)&#123; while(n&lt;j.length)&#123; result[k++] = j[n++]; &#125; &#125; return result;&#125; 线性排序-计数排序计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。 牺牲空间换取时间，当K=O(n)时计数排序速度快，否则复杂度将会更高 123456789101112131415161718192021222324int[] CountSort(int[]a)&#123; int b[] = new int[a.length]; int max = a[0],min = a[0]; for(int i:a)&#123; if(i&gt;max)&#123; max=i; &#125; if(i&lt;min)&#123; min=i; &#125; &#125; int k=max-min+1;//这里k的大小是要排序的数组中，元素大小的极值差+1 int c[]=new int[k]; for(int i=0;i&lt;a.length;++i)&#123;//O(n) c[a[i]-min]+=1;//优化过的地方，减小了数组c的大小 &#125; for(int i=1;i&lt;c.length;++i)&#123;//O(k) c[i]=c[i]+c[i-1]; &#125; for(int i=a.length-1;i&gt;=0;--i)&#123;//O(n) b[--c[a[i]-min]]=a[i];//按存取的方式取出c的元素 &#125; return b; &#125; 线性排序-桶排序与计数排序类似，桶排序也对输入加以限制来提高算法性能。换言之。如果输入的序列来自固定集合，则桶排序的效率较高。例如假设所有输入元素是在【0，k-1】上的整数集合，这就表示k是输入序列中最远距离元素的数目。桶排序采用K个计数器，第i个计数器记录第i个的元素出现次数。 1234567891011static int BUCKET=10;void BucketSort(int A[],int array_size)&#123; int[] bucket=new int[BUCKET]; for(int i=0;i&lt;BUCKET;i++)bucket[i]=0; for(int i=0;i&lt;array_size;i++)++bucket[A[i]]; for(int i=0,j=0;j&lt;BUCKET;j++)&#123; for(int k=bucket[j];k&gt;0;--k)&#123; A[i++]=j; &#125; &#125;&#125; 线性排序-基数排序1）取每个元素最低有效位 2）基于最低有效位对序列中的元素进行排序，并保持具有相同位的元素的原有次序（稳定排序） 3）对下一个最低有效位重复该过程 基数排序速度取决于内部基本操作。如果输入值具有的位数长度不等。还需要对附加位进行排序，这是基数排序最慢的部分之一，也是最难进行效率优化的部分之一。 算法灵活性不如其他排序算法，对于每一种不同类型数据，基数排序都需要重写，难以编写一个处理所有数据的通用基数排序算法。 12345678910111213141516171819202122232425void RadixSort(int[] number, int d)&#123; //d表示最大的数有多少位 int k = 0; int n = 1; int m = 1; //控制键值排序依据在哪一位 int[][]temp = new int[10][number.length]; //数组的第一维表示可能的余数0-9 int[]order = new int[10]; //数组orderp[i]用来表示该位是i的数的个数 while(m &lt;= d) &#123; for(int i = 0; i &lt; number.length; i++) &#123; int lsd = ((number[i] / n) % 10); temp[lsd][order[lsd]] = number[i]; order[lsd]++; &#125; for(int i = 0; i &lt; 10; i++) &#123; if(order[i] != 0) for(int j = 0; j &lt; order[i]; j++) &#123; number[k] = temp[i][j]; k++; &#125; order[i] = 0; &#125; n *= 10; k = 0; m++; &#125;&#125; 性能比较 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 插入排序 O($ n^2 $) O(n) O($n^2$) O(1) 稳定 冒泡排序 O($ n^2 $) O(n) O($n^2$) O(1) 稳定 选择排序 O($ n^2 $) O($ n^2 $) O($n^2$) O(1) 不稳定 希尔排序 O($ n \log n $)~O($n^2$) O($ n^{1.3} $) O($ n^2 $) O(1) 不稳定 快速排序 O($ n\log n $) O($ n\log n $) O($ n^2 $) O($\log n$)~O($n$) 不稳定 堆排序 O($ n\log n $) O($ n\log n $) O($ n\log n $) O(1) 不稳定 归并排序 O($ n\log n $) O($ n\log n $) O($ n\log n $) O(n) 稳定 线性排序-计数排序 O(n+k) O(n+k) O(n+k) O(1) 稳定 线性排序-桶排序 O(n+k) O(n+k) O($ n^2 $) O(n+k) 稳定 线性排序-基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 稳定 鸣谢感谢费劲心思整理此博客的杨学长杨学长博客：COKID]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 学习笔记]]></title>
    <url>%2F2018%2F08%2F16%2FSpringBoot%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、Spring Boot 入门1、Spring Boot 简介 简化Spring应用开发的一个框架； 整个Spring技术栈的一个大整合； J2EE开发的一站式解决方案； 2、微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过HTTP的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3、环境准备环境约束 –jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112” –maven3.x：maven 3.3以上版本；Apache Maven 3.3.9 –IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS –SpringBoot 1.5.9.RELEASE：1.5.9； 统一环境； 1、MAVEN设置；给maven 的settings.xml配置文件的profiles标签添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 2、IDEA设置整合maven进来； 4、Spring Boot HelloWorld一个功能： 浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串； 1、创建一个maven工程；（jar）2、导入spring boot相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、编写一个主程序；启动Spring Boot应用12345678910111213/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; 4、编写相关的Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello World!"; &#125;&#125; 5、运行主程序测试6、简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成jar包，直接使用java -jar的命令进行执行； 5、Hello World探究1、POM文件1、父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本； Spring Boot的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-==web==： ​ spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 2、主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot的配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class； ==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；== ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)； ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们； J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar； 6、使用Spring Initializer快速创建Spring Boot项目1、IDEA：使用 Spring Initializer快速创建项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目； 选择我们需要的模块；向导会联网创建Spring Boot项目； 默认生成的Spring Boot项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； 2、STS使用 Spring Starter Project快速创建项目 二、配置文件1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； •application.properties •application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法：1、基本语法k:(空格)v：表示一对键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2、值的写法字面量：普通的值（数字，字符串，布尔）​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）：用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入配置文件 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1、properties配置文件在idea中默认utf-8可能会乱码调整 2、@Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 3、配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4、@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class="Person"&gt; * &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName必须是邮箱格式 // @Email //@Value("$&#123;person.last-name&#125;") private String lastName; //@Value("#&#123;11*2&#125;") private Integer age; //@Value("true") private Boolean boss; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别； 想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.atguigu.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件 * */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService02()&#123; System.out.println("配置类@Bean给容器中添加组件了..."); return new HelloService(); &#125;&#125; ##4、配置文件占位符 1、随机数12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 2、占位符获取之前配置的值，如果没有可以是用:指定默认值123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 5、Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用application.properties的配置； 2、yml支持多文档块方式1234567891011121314151617181920server: port: 8081spring: profiles: active: prod---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod #指定属于哪个环境 3、激活指定profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 6、配置文件加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot会从这四个位置全部加载主配置文件；互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置； java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=G:/application.properties 7、外部配置加载顺序==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置== 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； –配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 ==由jar包外向jar包内进行寻找；== ==优先加载带profile== 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ==再来加载不带profile== 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源； 参考官方文档 8、自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 1、自动配置原理：1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration== 2）、@EnableAutoConfiguration 作用： 利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容； List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames()扫描所有jar包类路径下 META-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中 ​ ==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728@Configuration //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(HttpEncodingProperties.class) //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = "spring.http.encoding", value = "enabled", matchIfMissing = true) //判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final HttpEncodingProperties properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = "spring.http.encoding") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8"); 精髓： ​ 1）、SpringBoot启动会加载大量的自动配置类 ​ 2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties:封装配置文件中相关属性； 2、细节1、@Conditional派生注解（Spring注解版原生的@Conditional作用）作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效； ==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 三、日志1、日志框架 小张；开发一个大型系统； ​ 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？ ​ 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar； ​ 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？ ​ 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar； ​ 5、JDBC—数据库驱动； ​ 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar； ​ 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层； 市面上的日志框架； JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…. 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘ ​ ==SpringBoot选用 SLF4j和logback；== 2、SLF4j使用1、如何在系统中使用SLF4j https://www.slf4j.org以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和 logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j； ==1、将系统中其他日志框架先排除出去；== ==2、用中间包来替换原有的日志框架；== ==3、我们导入slf4j其他的实现== 3、SpringBoot日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录 ​ 2）、SpringBoot也把其他的日志都替换成了slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings("rawtypes")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = "http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"; static LogFactory logFactory = new SLF4JLogFactory(); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring框架用的是commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; ==SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；== 4、日志使用；1、默认配置SpringBoot默认帮我们配置好了日志； 123456789101112131415161718//记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; //System.out.println(); //日志的级别； //由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace("这是trace日志..."); logger.debug("这是debug日志..."); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别 logger.info("这是info日志..."); logger.warn("这是warn日志..."); logger.error("这是error日志...");&#125; 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger{50} 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.atguigu=trace#logging.path=# 不指定路径在当前项目下生成springboot.log日志# 可以指定完整的路径；#logging.file=G:/springboot.log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n logging.file logging.path Example Description (none) (none) 只在控制台输出 指定文件名 (none) my.log 输出日志到my.log文件 (none) 指定目录 /var/log 输出到指定目录的 spring.log 文件中 2、指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name="stdout" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式： %d表示日期时间， %thread表示线程名， %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息， %n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;springProfile name="dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name="!dev"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误 no applicable action for [springProfile] 5、切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式； 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 四、Web开发1、简介使用SpringBoot； 1）、创建SpringBoot应用，选中我们需要的模块； 2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来 3）、自己编写业务代码； 自动配置原理？ 这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx 12xxxxAutoConfiguration：帮我们给容器中自动配置组件；xxxxProperties:配置类来封装配置文件的内容； 2、SpringBoot对静态资源的映射规则；123@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties implements ResourceLoaderAware &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364WebMvcAuotConfiguration： @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Integer cachePeriod = this.resourceProperties.getCachePeriod(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler("/webjars/**") .addResourceLocations( "classpath:/META-INF/resources/webjars/") .setCachePeriod(cachePeriod)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); //静态资源文件夹映射 if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations( this.resourceProperties.getStaticLocations()) .setCachePeriod(cachePeriod)); &#125; &#125; //配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping( ResourceProperties resourceProperties) &#123; return new WelcomePageHandlerMapping(resourceProperties.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); &#125; //配置喜欢的图标 @Configuration @ConditionalOnProperty(value = "spring.mvc.favicon.enabled", matchIfMissing = true) public static class FaviconConfiguration &#123; private final ResourceProperties resourceProperties; public FaviconConfiguration(ResourceProperties resourceProperties) &#123; this.resourceProperties = resourceProperties; &#125; @Bean public SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); //所有 **/favicon.ico mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping; &#125; @Bean public ResourceHttpRequestHandler faviconRequestHandler() &#123; ResourceHttpRequestHandler requestHandler = new ResourceHttpRequestHandler(); requestHandler .setLocations(this.resourceProperties.getFaviconLocations()); return requestHandler; &#125; &#125; ==1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；== ​ webjars：以jar包的方式引入静态资源； http://www.webjars.org/ localhost:8080/webjars/jquery/3.3.1/jquery.js 123456&lt;!--引入jquery-webjar--&gt;在访问的时候只需要写webjars下面资源的名称即可 &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; ==2）、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射== 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径 localhost:8080/abc === 去静态资源文件夹里面找abc ==3）、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；== ​ localhost:8080/ 找index页面 ==4）、所有的 **/favicon.ico 都是在静态资源文件下找；== 3、模板引擎JSP、Velocity、Freemarker、Thymeleaf SpringBoot推荐的Thymeleaf； 语法更简单，功能更强大； 1、引入thymeleaf；123456789101112 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; 2.1.6 &lt;/dependency&gt;切换thymeleaf版本&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; 2、Thymeleaf使用1234567891011@ConfigurationProperties(prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName("UTF-8"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf("text/html"); public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; // 只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染； 使用： 1、导入thymeleaf的名称空间 1&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; 2、使用thymeleaf语法； 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为 --&gt; &lt;div th:text="$&#123;hello&#125;"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、语法规则1）、th:text；改变当前元素里面的文本内容； ​ th：任意html属性；来替换原生属性的值 2）、表达式？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Simple expressions:（表达式语法） Variable Expressions: $&#123;...&#125;：获取变量值；OGNL； 1）、获取对象的属性、调用方法 2）、使用内置的基本对象： #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. $&#123;session.foo&#125; 3）、内置的一些工具对象：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs/URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending/appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样； 补充：配合 th:object=&quot;$&#123;session.user&#125;： &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt; &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt; &lt;/div&gt; Message Expressions: #&#123;...&#125;：获取国际化内容 Link URL Expressions: @&#123;...&#125;：定义URL； @&#123;/order/process(execId=$&#123;execId&#125;,execType=&apos;FAST&apos;)&#125; Fragment Expressions: ~&#123;...&#125;：片段引用表达式 &lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt; Literals（字面量） Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,…Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): -Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , notComparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne )Conditional operators:条件运算（三元运算符） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 4、SpringMVC自动配置https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications 1. Spring MVC auto-configurationSpring Boot 自动配置好了SpringMVC 以下是SpringBoot对SpringMVC的默认配置:==（WebMvcAutoConfiguration）== Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. 自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？）） ContentNegotiatingViewResolver：组合所有的视图解析器的； ==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；== Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars Static index.html support. 静态首页访问 Custom Favicon support (see below). favicon.ico ​ 自动注册了 of Converter, GenericConverter, Formatter beans. Converter：转换器； public String hello(User user)：类型转换使用Converter Formatter 格式化器； 2017.12.17===Date； 12345@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125; ​ ==自己添加的格式化器转换器，我们只需要放在容器中即可== Support for HttpMessageConverters (see below). HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json； HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter； ==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）== ​ Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则 Automatic use of a ConfigurableWebBindingInitializer bean (see below). ==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）== 12初始化WebDataBinder；请求数据=====JavaBean； org.springframework.boot.autoconfigure.web：web的所有自动场景； If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path="/hello" view-name="success"/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/hello"/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; ==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==; 既保留了所有的自动配置，也能用我们扩展的配置； 1234567891011//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： ​ 1）、WebMvcAutoConfiguration是SpringMVC的自动配置类 ​ 2）、在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class) 123456789101112131415161718 @Configurationpublic static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); //从容器中获取所有的WebMvcConfigurer @Autowired(required = false) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); //一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用； @Override // public void addViewControllers(ViewControllerRegistry registry) &#123; // for (WebMvcConfigurer delegate : this.delegates) &#123; // delegate.addViewControllers(registry); // &#125; &#125; &#125;&#125; ​ 3）、容器中所有的WebMvcConfigurer都会一起起作用； ​ 4）、我们的配置类也会被调用； ​ 效果：SpringMVC的自动配置和我们的扩展配置都会起作用； 3、全面接管SpringMVC；SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可； 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125; 原理： 为什么@EnableWebMvc自动配置就失效了； 1）@EnableWebMvc的核心 12@Import(DelegatingWebMvcConfiguration.class)public @interface EnableWebMvc &#123; 2）、 12@Configurationpublic class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 3）、 12345678910@Configuration@ConditionalOnWebApplication@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurerAdapter.class &#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; 4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来； 5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能； 5、如何修改SpringBoot的默认配置模式： ​ 1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来； ​ 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置 ​ 3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置 6、RestfulCRUD1）、默认访问首页1234567891011121314151617181920212223242526//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能//@EnableWebMvc 不要接管SpringMVC@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125; //所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); &#125; &#125;; return adapter; &#125;&#125; 2）、国际化1）、编写国际化配置文件； 2）、使用ResourceBundleMessageSource管理国际化资源文件 3）、在页面使用fmt:message取出国际化内容 步骤： 1）、编写国际化配置文件，抽取页面需要显示的国际化消息 2）、SpringBoot自动配置好了管理国际化资源文件的组件； 12345678910111213141516171819202122232425262728@ConfigurationProperties(prefix = "spring.messages")public class MessageSourceAutoConfiguration &#123; /** * Comma-separated list of basenames (essentially a fully-qualified classpath * location), each following the ResourceBundle convention with relaxed support for * slash based locations. If it doesn't contain a package qualifier (such as * "org.mypackage"), it will be resolved from the classpath root. */ private String basename = "messages"; //我们的配置文件可以直接放在类路径下叫messages.properties； @Bean public MessageSource messageSource() &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(this.basename)) &#123; //设置国际化资源文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray( StringUtils.trimAllWhitespace(this.basename))); &#125; if (this.encoding != null) &#123; messageSource.setDefaultEncoding(this.encoding.name()); &#125; messageSource.setFallbackToSystemLocale(this.fallbackToSystemLocale); messageSource.setCacheSeconds(this.cacheSeconds); messageSource.setAlwaysUseMessageFormat(this.alwaysUseMessageFormat); return messageSource; &#125; 3）、去页面获取国际化的值； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href="asserts/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href="asserts/css/signin.css" th:href="@&#123;/asserts/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard.html"&gt; &lt;img class="mb-4" th:src="@&#123;/asserts/img/bootstrap-solid.svg&#125;" src="asserts/img/bootstrap-solid.svg" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.tip&#125;"&gt;Please sign in&lt;/h1&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only" th:text="#&#123;login.password&#125;"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果：根据浏览器语言设置的信息切换了国际化； 原理： ​ 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）； 12345678910111213 @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = "spring.mvc", name = "locale") public LocaleResolver localeResolver() &#123; if (this.mvcProperties .getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;默认的就是根据请求头带来的区域信息获取Locale进行国际化 4）、点击链接切换国际化 12345678910111213141516171819202122232425262728/** * 可以在连接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String l = request.getParameter("l"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(l))&#123; String[] split = l.split("_"); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 3）、登陆开发期间模板引擎页面修改以后，要实时生效 1）、禁用模板引擎的缓存 12# 禁用缓存spring.thymeleaf.cache=false 2）、页面修改完成以后ctrl+f9：重新编译； 登陆错误消息的显示 1&lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; 4）、拦截器进行登陆检查拦截器 12345678910111213141516171819202122232425262728293031/** * 登陆检查， */public class LoginHandlerInterceptor implements HandlerInterceptor &#123; //目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Object user = request.getSession().getAttribute("loginUser"); if(user == null)&#123; //未登陆，返回登陆页面 request.setAttribute("msg","没有权限请先登陆"); request.getRequestDispatcher("/index.html").forward(request,response); return false; &#125;else&#123; //已登陆，放行请求 return true; &#125; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125;&#125; 注册拦截器 1234567891011121314151617181920212223//所有的WebMvcConfigurerAdapter组件都会一起起作用 @Bean //将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/").setViewName("login"); registry.addViewController("/index.html").setViewName("login"); registry.addViewController("/main.html").setViewName("dashboard"); &#125; //注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; //super.addInterceptors(registry); //静态资源； *.css , *.js //SpringBoot已经做好了静态资源映射 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**") .excludePathPatterns("/index.html","/","/user/login"); &#125; &#125;; return adapter; &#125; 5）、CRUD-员工列表实验要求： 1）、RestfulCRUD：CRUD满足Rest风格； URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作 普通CRUD（uri来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 2）、实验的请求架构; 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工(来到修改页面) emp/1 GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/1 GET 修改员工 emp PUT 删除员工 emp/1 DELETE 3）、员工列表： thymeleaf公共页面元素抽取12345678910111213141、抽取公共片段&lt;div th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;2、引入公共片段&lt;div th:insert="~&#123;footer :: copy&#125;"&gt;&lt;/div&gt;~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名3、默认效果：insert的公共片段在div标签中如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]； 三种引入公共片段的th属性： th:insert：将公共片段整个插入到声明引入的元素中 th:replace：将声明引入的元素替换为公共片段 th:include：将被引入的片段的内容包含进这个标签中 1234567891011121314151617181920212223&lt;footer th:fragment="copy"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;引入方式&lt;div th:insert="footer :: copy"&gt;&lt;/div&gt;&lt;div th:replace="footer :: copy"&gt;&lt;/div&gt;&lt;div th:include="footer :: copy"&gt;&lt;/div&gt;效果&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段的时候传入参数： 123456789101112131415161718&lt;nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"&gt; &lt;div class="sidebar-sticky"&gt; &lt;ul class="nav flex-column"&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link active" th:class="$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;" href="#" th:href="@&#123;/main.html&#125;"&gt; &lt;svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"&gt; &lt;path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"&gt;&lt;/path&gt; &lt;polyline points="9 22 9 12 15 12 15 22"&gt;&lt;/polyline&gt; &lt;/svg&gt; Dashboard &lt;span class="sr-only"&gt;(current)&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;!--引入侧边栏;传入参数--&gt;&lt;div th:replace="commons/bar::#sidebar(activeUri='emps')"&gt;&lt;/div&gt; 6）、CRUD-员工添加添加页面 123456789101112131415161718192021222324252627282930313233343536&lt;form&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input type="email" class="form-control" placeholder="zhangsan@atguigu.com"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;select class="form-control"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input type="text" class="form-control" placeholder="zhangsan"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary"&gt;添加&lt;/button&gt;&lt;/form&gt; 提交的数据格式不对：生日：日期； 2017-12-12；2017/12/12；2017.12.12； 日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型; 2017-12-12—Date； 类型转换，格式化; 默认日期是按照/的方式； 7）、CRUD-员工修改修改添加二合一表单 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--需要区分是员工修改还是添加；--&gt;&lt;form th:action="@&#123;/emp&#125;" method="post"&gt; &lt;!--发送put请求修改员工数据--&gt; &lt;!--1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）2、页面创建一个post表单3、创建一个input项，name="_method";值就是我们指定的请求方式--&gt; &lt;input type="hidden" name="_method" value="put" th:if="$&#123;emp!=null&#125;"/&gt; &lt;input type="hidden" name="id" th:if="$&#123;emp!=null&#125;" th:value="$&#123;emp.id&#125;"&gt; &lt;div class="form-group"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name="lastName" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name="email" type="email" class="form-control" placeholder="zhangsan@atguigu.com" th:value="$&#123;emp!=null&#125;?$&#123;emp.email&#125;"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="1" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"&gt; &lt;label class="form-check-label"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class="form-check form-check-inline"&gt; &lt;input class="form-check-input" type="radio" name="gender" value="0" th:checked="$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"&gt; &lt;label class="form-check-label"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class="form-control" name="department.id"&gt; &lt;option th:selected="$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;" th:value="$&#123;dept.id&#125;" th:each="dept:$&#123;depts&#125;" th:text="$&#123;dept.departmentName&#125;"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;input name="birth" type="text" class="form-control" placeholder="zhangsan" th:value="$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-primary" th:text="$&#123;emp!=null&#125;?'修改':'添加'"&gt;添加&lt;/button&gt;&lt;/form&gt; 8）、CRUD-员工删除123456789101112131415161718192021&lt;tr th:each="emp:$&#123;emps&#125;"&gt; &lt;td th:text="$&#123;emp.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text="$&#123;emp.email&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.gender&#125;==0?'女':'男'"&gt;&lt;/td&gt; &lt;td th:text="$&#123;emp.department.departmentName&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class="btn btn-sm btn-primary" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;"&gt;编辑&lt;/a&gt; &lt;button th:attr="del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-danger deleteBtn"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(".deleteBtn").click(function()&#123; //删除当前员工的 $("#deleteEmpForm").attr("action",$(this).attr("del_uri")).submit(); return false; &#125;);&lt;/script&gt; 7、错误处理机制1）、SpringBoot默认的错误处理机制默认效果： ​ 1）、浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： ​ 2）、如果是其他客户端，默认响应一个json数据 ​ 原理： ​ 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了以下组件 ​ 1、DefaultErrorAttributes： 1234567891011帮我们在页面共享信息；@Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put("timestamp", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes; &#125; ​ 2、BasicErrorController：处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = "text/html")//产生html类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面；包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView("error", model) : modelAndView); &#125; @RequestMapping @ResponseBody //产生json数据，其他客户端来到这个方法处理； public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; ​ 3、ErrorPageCustomizer： 12@Value("$&#123;error.path:/error&#125;")private String path = "/error"; 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） ​ 4、DefaultErrorViewResolver： 123456789101112131415161718192021222324@Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = "error/" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; ​ 步骤： ​ 一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面；去哪个页面是由DefaultErrorViewResolver解析得到的； 1234567891011protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到ModelAndView for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null;&#125; 2）、如果定制错误响应：1）、如何定制错误的页面；​ 1）、有模板引擎的情况下；error/状态码; 【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面； ​ 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）； ​ 页面能获取的信息； ​ timestamp：时间戳 ​ status：状态码 ​ error：错误提示 ​ exception：异常对象 ​ message：异常消息 ​ errors：JSR303数据校验的错误都在这里 ​ 2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找； ​ 3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面； 2）、如何定制错误的json数据；​ 1）、自定义异常处理&amp;返回定制json数据； 12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("code","user.notexist"); map.put("message",e.getMessage()); return map; &#125;&#125;//没有自适应效果... ​ 2）、转发到/error进行自适应响应效果处理 1234567891011121314@ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute("javax.servlet.error.status_code"); */ request.setAttribute("javax.servlet.error.status_code",500); map.put("code","user.notexist"); map.put("message",e.getMessage()); //转发到/error return "forward:/error"; &#125; 3）、将我们的定制数据携带出去；出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）； ​ 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； ​ 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； ​ 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的； 自定义ErrorAttributes 1234567891011//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put("company","atguigu"); return map; &#125;&#125; 最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容， 8、配置嵌入式Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 问题？ 1）、如何定制和修改Servlet容器的相关配置；1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）； 123456789server.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8//通用的Servlet容器设置server.xxx//Tomcat的设置server.tomcat.xxx 2、编写一个EmbeddedServletContainerCustomizer：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置 1234567891011@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; 2）、注册Servlet三大组件【Servlet、Filter、Listener】由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式 ServletRegistrationBean 123456//注册三大组件@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; FilterRegistrationBean 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; ServletListenerRegistrationBean 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet； DispatcherServletAutoConfiguration中： 1234567891011121314151617@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public ServletRegistrationBean dispatcherServletRegistration( DispatcherServlet dispatcherServlet) &#123; ServletRegistrationBean registration = new ServletRegistrationBean( dispatcherServlet, this.serverProperties.getServletMapping()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME); registration.setLoadOnStartup( this.webMvcProperties.getServlet().getLoadOnStartup()); if (this.multipartConfig != null) &#123; registration.setMultipartConfig(this.multipartConfig); &#125; return registration;&#125; 2）、SpringBoot能不能支持其他的Servlet容器； 3）、替换为其他嵌入式Servlet容器 默认支持： Tomcat（默认使用） 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; 引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；&lt;/dependency&gt; Jetty 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 4）、嵌入式Servlet容器自动配置原理；EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)@Configuration@ConditionalOnWebApplication@Import(BeanPostProcessorsRegistrar.class)//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作public class EmbeddedServletContainerAutoConfiguration &#123; @Configuration @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖； @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器 public static class EmbeddedTomcat &#123; @Bean public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123; return new TomcatEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Jetty is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123; return new JettyEmbeddedServletContainerFactory(); &#125; &#125; /** * Nested configuration if Undertow is being used. */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123; return new UndertowEmbeddedServletContainerFactory(); &#125; &#125; 1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂） 1234567public interface EmbeddedServletContainerFactory &#123; //获取嵌入式的Servlet容器 EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers);&#125; 2）、EmbeddedServletContainer：（嵌入式的Servlet容器） 3）、以TomcatEmbeddedServletContainerFactory为例 123456789101112131415161718192021222324@Overridepublic EmbeddedServletContainer getEmbeddedServletContainer( ServletContextInitializer... initializers) &#123; //创建一个Tomcat Tomcat tomcat = new Tomcat(); //配置Tomcat的基本环节 File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir("tomcat")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) &#123; tomcat.getService().addConnector(additionalConnector); &#125; prepareContext(tomcat.getHost(), initializers); //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器 return getTomcatEmbeddedServletContainer(tomcat);&#125; 4）、我们对嵌入式容器的配置修改是怎么生效？ 1ServerProperties、EmbeddedServletContainerCustomizer EmbeddedServletContainerCustomizer：定制器帮我们修改了Servlet容器的配置？ 怎么修改的原理？ 5）、容器中导入了EmbeddedServletContainerCustomizerBeanPostProcessor 12345678910111213141516171819202122232425262728293031323334353637//初始化之前@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件 if (bean instanceof ConfigurableEmbeddedServletContainer) &#123; // postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean); &#125; return bean;&#125;private void postProcessBeforeInitialization( ConfigurableEmbeddedServletContainer bean) &#123; //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值； for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123; customizer.customize(bean); &#125;&#125;private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123; if (this.customizers == null) &#123; // Look up does not include the parent context this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;( this.beanFactory //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件 .getBeansOfType(EmbeddedServletContainerCustomizer.class, false, false) .values()); Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE); this.customizers = Collections.unmodifiableList(this.customizers); &#125; return this.customizers;&#125;ServerProperties也是定制器 步骤： 1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】 2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor； 只要是嵌入式的Servlet容器工厂，后置处理器就工作； 3）、后置处理器，从容器中获取所有的EmbeddedServletContainerCustomizer，调用定制器的定制方法 ###5）、嵌入式Servlet容器启动原理； 什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat； 获取嵌入式的Servlet容器工厂： 1）、SpringBoot应用启动运行run方法 2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则：AnnotationConfigApplicationContext 3）、refresh(context);刷新刚才创建好的ioc容器； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 4）、 onRefresh(); web的ioc容器重写了onRefresh方法 5）、webioc容器会创建嵌入式的Servlet容器；createEmbeddedServletContainer(); 6）、获取嵌入式的Servlet容器工厂： EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory(); ​ 从ioc容器中获取EmbeddedServletContainerFactory 组件；TomcatEmbeddedServletContainerFactory创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置； 7）、使用容器工厂获取嵌入式的Servlet容器：this.embeddedServletContainer = containerFactory .getEmbeddedServletContainer(getSelfInitializer()); 8）、嵌入式的Servlet容器创建对象并启动Servlet容器； 先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来； ==IOC容器启动创建嵌入式的Servlet容器== 9、使用外置的Servlet容器嵌入式Servlet容器：应用打成可执行的jar ​ 优点：简单、便携； ​ 缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）； 外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、启动服务器就可以使用； 原理jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器； war包：启动服务器，服务器启动SpringBoot应用【SpringBootServletInitializer】，启动ioc容器； servlet3.0（Spring注解版）： 8.2.4 Shared libraries / runtimes pluggability： 规则： ​ 1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例： ​ 2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名 ​ 3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类； 流程： 1）、启动Tomcat 2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer： Spring的web模块里面有这个文件：org.springframework.web.SpringServletContainerInitializer 3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例； 4）、每一个WebApplicationInitializer都调用自己的onStartup； 5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法 6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器 1234567891011121314151617181920212223242526272829303132333435363738protected WebApplicationContext createRootApplicationContext( ServletContext servletContext) &#123; //1、创建SpringApplicationBuilder SpringApplicationBuilder builder = createSpringApplicationBuilder(); StandardServletEnvironment environment = new StandardServletEnvironment(); environment.initPropertySources(servletContext, null); builder.environment(environment); builder.main(getClass()); ApplicationContext parent = getExistingRootWebApplicationContext(servletContext); if (parent != null) &#123; this.logger.info("Root context already created (using as parent)."); servletContext.setAttribute( WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null); builder.initializers(new ParentContextApplicationContextInitializer(parent)); &#125; builder.initializers( new ServletContextApplicationContextInitializer(servletContext)); builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class); //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来 builder = configure(builder); //使用builder创建一个Spring应用 SpringApplication application = builder.build(); if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils .findAnnotation(getClass(), Configuration.class) != null) &#123; application.getSources().add(getClass()); &#125; Assert.state(!application.getSources().isEmpty(), "No SpringApplication sources have been defined. Either override the " + "configure method or add an @Configuration annotation"); // Ensure error pages are registered if (this.registerErrorPageFilter) &#123; application.getSources().add(ErrorPageFilterConfiguration.class); &#125; //启动Spring应用 return run(application);&#125; 7）、Spring的应用就启动并且创建IOC容器 1234567891011121314151617181920212223242526272829303132333435public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); Banner printedBanner = printBanner(environment); context = createApplicationContext(); analyzers = new FailureAnalyzers(context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新IOC容器 refreshContext(context); afterRefresh(context, applicationArguments); listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; ==启动Servlet容器，再启动SpringBoot应用== 五、Docker1、简介Docker是一个开源的应用容器引擎；是一个轻量级容器技术； Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像； 运行中的这个镜像称为容器，容器启动是非常快速的。 2、核心概念docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）； docker客户端(Client)：连接docker主机进行操作； docker仓库(Registry)：用来保存各种打包好的软件镜像； docker镜像(SpringBoot笔记)：软件打包好的镜像；放在docker仓库中； docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用 使用Docker的步骤： 1）、安装Docker 2）、去Docker仓库找到这个软件对应的镜像； 3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器； 4）、对容器的启动停止就是对软件的启动停止； 3、安装Docker1）、安装linux虚拟机​ 1）、VMWare、VirtualBox（安装）； ​ 2）、导入虚拟机文件centos7-atguigu.ova； ​ 3）、双击启动linux虚拟机;使用 root/ 123456登陆 ​ 4）、使用客户端连接linux服务器进行命令操作； ​ 5）、设置虚拟机网络； ​ 桥接网络===选好网卡====接入网线； ​ 6）、设置好网络以后使用命令重启虚拟机的网络 1service network restart ​ 7）、查看linux的ip地址 1ip addr ​ 8）、使用客户端连接linux； 2）、在linux虚拟机上安装docker步骤： 12345678910111213141、检查内核版本，必须是3.10及以上uname -r2、安装dockeryum install docker3、输入y确认安装4、启动docker[root@localhost ~]# systemctl start docker[root@localhost ~]# docker -vDocker version 1.12.6, build 3e8e77d/1.12.65、开机启动docker[root@localhost ~]# systemctl enable dockerCreated symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.6、停止dockersystemctl stop docker 4、Docker常用命令&amp;操作1）、镜像操作 操作 命令 说明 检索 docker search 关键字 eg：docker search redis 我们经常去docker hub上检索镜像的详细信息，如镜像的TAG。 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是latest 列表 docker images 查看所有本地镜像 删除 docker rmi image-id 删除指定的本地镜像 https://hub.docker.com/ 2）、容器操作软件镜像（QQ安装程序）—-运行镜像—-产生一个容器（正在运行的软件，运行的QQ）； 步骤： 1234567891011121314151617181920212223242526272829301、搜索镜像[root@localhost ~]# docker search tomcat2、拉取镜像[root@localhost ~]# docker pull tomcat3、根据镜像启动容器docker run --name mytomcat -d tomcat:latest4、docker ps 查看运行中的容器5、 停止运行中的容器docker stop 容器的id6、查看所有的容器docker ps -a7、启动容器docker start 容器id8、删除一个容器 docker rm 容器id9、启动一个做了端口映射的tomcat[root@localhost ~]# docker run -d -p 8888:8080 tomcat-d：后台运行-p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口10、为了演示简单关闭了linux的防火墙service firewalld status ；查看防火墙状态service firewalld stop：关闭防火墙11、查看容器的日志docker logs container-name/container-id更多命令参看https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 3）、安装MySQL示例1docker pull mysql 错误的启动 1234567891011121314151617[root@localhost ~]# docker run --name mysql01 -d mysql42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846mysql退出了[root@localhost ~]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES42f09819908b mysql "docker-entrypoint.sh" 34 seconds ago Exited (1) 33 seconds ago mysql01538bde63e500 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago compassionate_goldstinec4f1ac60b3fc tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago lonely_fermi81ec743a5271 tomcat "catalina.sh run" About an hour ago Exited (143) About an hour ago sick_ramanujan//错误日志[root@localhost ~]# docker logs 42f09819908berror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个 正确的启动 12345[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlb874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESb874c56bec49 mysql "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mysql01 做了端口映射 12345[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysqlad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434[root@localhost ~]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESad10e4bc5c6a mysql "docker-entrypoint.sh" 4 seconds ago Up 2 seconds 0.0.0.0:3306-&gt;3306/tcp mysql02 几个其他的高级操作 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 六、SpringBoot与数据访问1、JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.15.22:3306/jdbc driver-class-name: com.mysql.jdbc.Driver 效果： ​ 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源； ​ 数据源的相关配置都在DataSourceProperties里面； 自动配置原理： org.springframework.boot.autoconfigure.jdbc： 1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型； 2、SpringBoot默认可以支持； 1org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、 3、自定义数据源类型 1234567891011121314/** * Generic DataSource configuration. */@ConditionalOnMissingBean(DataSource.class)@ConditionalOnProperty(name = "spring.datasource.type")static class Generic &#123; @Bean public DataSource dataSource(DataSourceProperties properties) &#123; //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性 return properties.initializeDataSourceBuilder().build(); &#125;&#125; 4、DataSourceInitializer：ApplicationListener； ​ 作用： ​ 1）、runSchemaScripts();运行建表语句； ​ 2）、runDataScripts();运行插入数据的sql语句； 默认只需要将文件命名为： 123456schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；可以使用 schema: - classpath:department.sql 指定位置 5、操作数据库：自动配置了JdbcTemplate操作数据库 2、整合Druid数据源12345678910111213141516171819202122232425262728293031323334353637383940414243导入druid数据源@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), "/druid/*"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow","");//默认就是允许所有访问 initParams.put("deny","192.168.15.21"); bean.setInitParameters(initParams); return bean; &#125; //2、配置一个web监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 3、整合MyBatis12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 步骤： ​ 1）、配置数据源相关属性（见上一节Druid） ​ 2）、给数据库建表 ​ 3）、创建JavaBean 4）、注解版1234567891011121314151617//指定这是一个操作数据库的mapper@Mapperpublic interface DepartmentMapper &#123; @Select("select * from department where id=#&#123;id&#125;") public Department getDeptById(Integer id); @Delete("delete from department where id=#&#123;id&#125;") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into department(departmentName) values(#&#123;departmentName&#125;)") public int insertDept(Department department); @Update("update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;") public int updateDept(Department department);&#125; 问题： 自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer； 1234567891011121314@org.springframework.context.annotation.Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125;&#125; 123456789使用MapperScan批量扫描所有的Mapper接口；@MapperScan(value = "com.atguigu.springboot.mapper")@SpringBootApplicationpublic class SpringBoot06DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot06DataMybatisApplication.class, args); &#125;&#125; 5）、配置文件版123mybatis: config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 指定sql映射文件的位置 更多使用参照 http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/ 4、整合SpringData JPA1）、SpringData简介 2）、整合SpringData JPAJPA:ORM（Object Relational Mapping）； 1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系； 12345678910111213//使用JPA注解配置映射关系@Entity //告诉JPA这是一个实体类（和数据表映射的类）@Table(name = "tbl_user") //@Table来指定和哪个数据表对应;如果省略默认表名就是user；public class User &#123; @Id //这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键 private Integer id; @Column(name = "last_name",length = 50) //这是和数据表对应的一个列 private String lastName; @Column //省略默认列名就是属性名 private String email; 2）、编写一个Dao接口来操作实体类对应的数据表（Repository） 123//继承JpaRepository来完成对数据库的操作public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; 3）、基本的配置JpaProperties 1234567spring: jpa: hibernate:# 更新或者创建数据表结构 ddl-auto: update# 控制台显示SQL show-sql: true 七、启动配置原理几个重要的事件回调机制 配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 启动流程： 1、创建SpringApplication对象12345678910111213141516initialize(sources);private void initialize(Object[] sources) &#123; //保存主配置类 if (sources != null &amp;&amp; sources.length &gt; 0) &#123; this.sources.addAll(Arrays.asList(sources)); &#125; //判断当前是否一个web应用 this.webEnvironment = deduceWebEnvironment(); //从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来 setInitializers((Collection) getSpringFactoriesInstances( ApplicationContextInitializer.class)); //从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //从多个配置类中找到有main方法的主配置类 this.mainApplicationClass = deduceMainApplicationClass();&#125; 2、运行run方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; FailureAnalyzers analyzers = null; configureHeadlessProperty(); //获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的获取SpringApplicationRunListener.starting()方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); //准备环境 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成 Banner printedBanner = printBanner(environment); //创建ApplicationContext；决定创建web的ioc还是普通的ioc context = createApplicationContext(); analyzers = new FailureAnalyzers(context); //准备上下文环境;将environment保存到ioc中；而且applyInitializers()； //applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法 //回调所有的SpringApplicationRunListener的contextPrepared()； // prepareContext(context, environment, listeners, applicationArguments, printedBanner); //prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）； //s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版 //扫描，创建，加载所有组件的地方；（配置类，组件，自动配置） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调 //ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); //所有的SpringApplicationRunListener回调finished方法 listeners.finished(context, null); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; //整个SpringBoot应用启动完成以后返回启动的ioc容器； return context; &#125; catch (Throwable ex) &#123; handleRunFailure(context, listeners, analyzers, ex); throw new IllegalStateException(ex); &#125;&#125; 3、事件监听机制配置在META-INF/spring.factories ApplicationContextInitializer 123456public class HelloApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123; @Override public void initialize(ConfigurableApplicationContext applicationContext) &#123; System.out.println("ApplicationContextInitializer...initialize..."+applicationContext); &#125;&#125; SpringApplicationRunListener 123456789101112131415161718192021222324252627282930313233public class HelloSpringApplicationRunListener implements SpringApplicationRunListener &#123; //必须有的构造器 public HelloSpringApplicationRunListener(SpringApplication application, String[] args)&#123; &#125; @Override public void starting() &#123; System.out.println("SpringApplicationRunListener...starting..."); &#125; @Override public void environmentPrepared(ConfigurableEnvironment environment) &#123; Object o = environment.getSystemProperties().get("os.name"); System.out.println("SpringApplicationRunListener...environmentPrepared.."+o); &#125; @Override public void contextPrepared(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextPrepared..."); &#125; @Override public void contextLoaded(ConfigurableApplicationContext context) &#123; System.out.println("SpringApplicationRunListener...contextLoaded..."); &#125; @Override public void finished(ConfigurableApplicationContext context, Throwable exception) &#123; System.out.println("SpringApplicationRunListener...finished..."); &#125;&#125; 配置（META-INF/spring.factories） 12345org.springframework.context.ApplicationContextInitializer=\com.atguigu.springboot.listener.HelloApplicationContextInitializerorg.springframework.boot.SpringApplicationRunListener=\com.atguigu.springboot.listener.HelloSpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner 1234567@Componentpublic class HelloApplicationRunner implements ApplicationRunner &#123; @Override public void run(ApplicationArguments args) throws Exception &#123; System.out.println("ApplicationRunner...run...."); &#125;&#125; CommandLineRunner 1234567@Componentpublic class HelloCommandLineRunner implements CommandLineRunner &#123; @Override public void run(String... args) throws Exception &#123; System.out.println("CommandLineRunner...run..."+ Arrays.asList(args)); &#125;&#125; 八、自定义starterstarter： ​ 1、这个场景需要使用到的依赖是什么？ ​ 2、如何编写自动配置 12345678910111213@Configuration //指定这个类是一个配置类@ConditionalOnXXX //在指定条件成立的情况下自动配置类生效@AutoConfigureAfter //指定自动配置类的顺序@Bean //给容器中添加组件@ConfigurationPropertie结合相关xxxProperties类来绑定相关的配置@EnableConfigurationProperties //让xxxProperties生效加入到容器中自动配置类要能加载将需要启动就加载的自动配置类，配置在META-INF/spring.factoriesorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\ ​ 3、模式： 启动器只用来做依赖导入； 专门来写一个自动配置模块； 启动器依赖自动配置；别人只需要引入启动器（starter） mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter 步骤： 1）、启动器模块 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--启动器--&gt; &lt;dependencies&gt; &lt;!--引入自动配置模块--&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）、自动配置模块 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu.starter&lt;/groupId&gt; &lt;artifactId&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;atguigu-spring-boot-starter-autoconfigurer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.10.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入spring-boot-starter；所有starter的基本配置--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526package com.atguigu.starter;import org.springframework.boot.context.properties.ConfigurationProperties;@ConfigurationProperties(prefix = "atguigu.hello")public class HelloProperties &#123; private String prefix; private String suffix; public String getPrefix() &#123; return prefix; &#125; public void setPrefix(String prefix) &#123; this.prefix = prefix; &#125; public String getSuffix() &#123; return suffix; &#125; public void setSuffix(String suffix) &#123; this.suffix = suffix; &#125;&#125; 123456789101112131415161718package com.atguigu.starter;public class HelloService &#123; HelloProperties helloProperties; public HelloProperties getHelloProperties() &#123; return helloProperties; &#125; public void setHelloProperties(HelloProperties helloProperties) &#123; this.helloProperties = helloProperties; &#125; public String sayHellAtguigu(String name)&#123; return helloProperties.getPrefix()+"-" +name + helloProperties.getSuffix(); &#125;&#125; 12345678910111213141516171819202122package com.atguigu.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration@ConditionalOnWebApplication //web应用才生效@EnableConfigurationProperties(HelloProperties.class)public class HelloServiceAutoConfiguration &#123; @Autowired HelloProperties helloProperties; @Bean public HelloService helloService()&#123; HelloService service = new HelloService(); service.setHelloProperties(helloProperties); return service; &#125;&#125; 更多SpringBoot整合示例https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples 后续：缓存（整合Redis），消息中间件（整合RabbitMQ），检索（整合ElasticSearch），任务（异步任务，定时任务，邮件任务），安全（整合SpringSecurity），分布式（整合Zookeeper/dubbo，整合SpringCloud），SpringBoot应用监管； 声明：感谢尚硅谷！！！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JRebel和LiveRebel执行热部署]]></title>
    <url>%2F2018%2F06%2F03%2F%E7%94%A8JRebel%E5%92%8CLiveRebel%E6%89%A7%E8%A1%8C%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[用JRebel和LiveRebel执行热部署前言​ 有人问：Java是解释型语言还是编译型语言？你可以毫不犹豫的告诉他：都是！Java是一种静态类型、动态编译、面向对象的语言”。 当然，这里所谓的编译可不是 .java 源文件编译为 .class 文件的过程，而是 .class 文件被JVM解释后会被即时编译（JITing）。当然，这不是今天要讨论的重点。 由于Java是编译型语言，也就是说没次修改代码之后都必须重复下列步骤： 重新编译Java代码 停止web服务器 将改动过的应用重新部署到服务器 启动web服务器 因此浪费很多的时间，而我们首先应该想到的应该就是 “热部署”！ JRebelhttps://zeroturnaround.com/software/jrebel/ JRebel处于IDE和Web服务器之间，当源代码发生变化时能自动将这些变化反映到正在运行的Web服务器上（LibeRebel用于生产环境的不熟）。这种热部署没有什么问题，并且这些工具实际上是解决热部署问题的行业标准。 安装IDEA JRebel插件 当然是先去网站注册了，注册可以获得 14 天的免费使用，14天之后。。。。。。。 注册完成后就来IDEA 插件仓库下载JRebel插件吧 插件安装完成后，在IDEA导航栏的help菜单下会看到 JRebel 选项，选择后去激活插件 插件激活后你就会看到多了两个绿色的小按钮，前面是run 后面是debug 在IDEA窗口左侧勾选要运行的项目 调整一下tomcat设置 最后，就可以愉快的debug了！ 最后 哈哈，你会发现，当你修改java代码后，他会自动热部署，再也不需要手动去restart server 了！！！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射在数据访问中的应用]]></title>
    <url>%2F2018%2F05%2F21%2FJava%E5%8F%8D%E5%B0%84%E5%9C%A8%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Java 反射在数据访问中的应用问题： 在做一个系统的过程中，难免会遇到一个系统要有不只一套数据库管理系统的情况。 然而对于这种情况，我们总不可能去做两套系统，所有，Java反射给我们带来了很大的便利。 代码： 比如这有一个例子： ​ 一套系统，要支持两套数据库：mysql、oracle 1234//db.properties#dbName = MySqldbName = Oracle 我们把数据库写到配置文件db.properties配置文件中，防止修改数据库代码重新编译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Userpackage com.test.model;public class User &#123; private int id; public User(int id) &#123; this.id = id; &#125; public User() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125;// Departmentpackage com.test.model;public class Department &#123; private int id; public Department() &#123; &#125; public Department(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125; 两个model层实体类，分别对应数据库中两张表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// IUserpackage com.test.methods;import com.test.model.User;public interface IUser &#123; void insert(User user); User getUser(int id);&#125;// MySqlUserpackage com.test.methods;import com.test.model.User;public class MySqlUser implements IUser &#123; @Override public void insert(User user) &#123; System.out.println(&quot;在mysql中给user增加一条记录&quot;); &#125; @Override public User getUser(int id) &#123; System.out.println(&quot;在mysql中根据id得到user中的一条记录&quot;); return null; &#125;&#125;// OracleUserpackage com.test.methods;import com.test.model.User;public class OracleUser implements IUser &#123; @Override public void insert(User user) &#123; System.out.println(&quot;在Oracle中给user插入一条记录&quot;); &#125; @Override public User getUser(int id) &#123; System.out.println(&quot;从oracle中根据id得到user一条记录&quot;); return null; &#125;&#125; 关于User代码。当然Department类似，有IDepartment接口、MySqlDepartment、OracleDepartment 123456789101112131415161718192021222324252627282930313233343536373839// DataAccesspackage com.test;import com.test.methods.IDepartment;import com.test.methods.IUser;import java.io.IOException;import java.io.InputStream;import java.util.Properties;public class DataAccess &#123; private static String packageName = &quot;com.test.methods.&quot;; // 要反射的类的包名 private static String dbName; // 类初始化时执行且仅执行一次 static &#123; InputStream in = DataAccess.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); // 读取配置文件 Properties properties = new Properties(); try &#123; properties.load(in); dbName = properties.getProperty(&quot;dbName&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 根据反射得到的类创建不同的实例 public static IUser createUser() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName(packageName + dbName+&quot;User&quot;); //拼接要反射的Class的完整类名 return (IUser) clazz.newInstance(); // 返回创建的实例 &#125; public static IDepartment createDepartment() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; Class clazz = Class.forName(packageName + dbName+&quot;Department&quot;); return (IDepartment) clazz.newInstance(); &#125;&#125; 工具类DataAccess ,首先读取配置文件，然后根据配置文件内容利用反射动态创建不同实例对象 1234567891011121314151617181920212223242526272829303132// Mainpackage com.test;import com.test.methods.IDepartment;import com.test.model.Department;import com.test.model.User;import com.test.methods.IUser;public class Main &#123; public static void main(String[] args) &#123; User user = new User(); user.setId(1); Department department = new Department(); department.setId(1); try &#123; IUser iu = DataAccess.createUser(); iu.insert(user); iu.getUser(1); IDepartment id = DataAccess.createDepartment(); id.insert(department); id.getDepartment(1); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后Main方法 最终运行结果是这样子的 12345678910111213在Oracle中给user插入一条记录从oracle中根据id得到user一条记录在Oracle中给department插入一条记录从oracle中根据id得到department一条记录Process finished with exit code 0------------------------------------------在mysql中给user增加一条记录在mysql中根据id得到user中的一条记录在mysql中给department增加一条记录在mysql中根据id得到department中的一条记录Process finished with exit code 0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe嵌套界面自适应]]></title>
    <url>%2F2018%2F05%2F17%2Fiframe%E5%B5%8C%E5%A5%97%E7%95%8C%E9%9D%A2%E8%87%AA%E9%80%82%E5%BA%94%2F</url>
    <content type="text"><![CDATA[iframe嵌套界面自适应前言 在web开发过程中，遇到页面嵌套页面的时候，第一首先想的的当然是iframe这个玩意，虽然很不推荐用这玩意（也是由很多坑的），但是在某些特定情况下用起来还是非常方便的。 问题 日常我们习惯去这样用：&lt;iframe scrolling=&quot;no&quot; frameborder=&quot;0&quot; id=&quot;main_frame&quot;&gt;&lt;/iframe&gt;，在确定页面大小的情况下(数据分页显示)这样是没什么问题的，隐藏iframe滚动条。但是在某些页面内容不确定情况下，隐藏其滚动条后会导致页面高度定死，页面下面数据显示不全问题。 解决 1234567891011121314151617181920212223&lt;script&gt; // 计算页面的实际高度，iframe自适应会用到 function calcPageHeight(doc) &#123; var cHeight = Math.max(doc.body.clientHeight, doc.documentElement.clientHeight) var sHeight = Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight) var height = Math.max(cHeight, sHeight) return height &#125; //根据ID获取iframe对象 var ifr = document.getElementById(&apos;main_frame&apos;) ifr.onload = function() &#123; //解决打开高度太高的页面后再打开高度较小页面滚动条不收缩 ifr.style.height=&apos;0px&apos;; var iDoc = ifr.contentDocument || ifr.document var height = calcPageHeight(iDoc) if(height &lt; 850)&#123; height = 850; &#125; ifr.style.height = height + &apos;px&apos; &#125; &lt;/script&gt; 引用自：https://blog.csdn.net/ron03129596/article/details/68947375 直接copy这段代码进parent页面分分钟搞定，使frame页面自适应，切不显示滚动条！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ajax异步请求的使用]]></title>
    <url>%2F2018%2F05%2F15%2F%E5%85%B3%E4%BA%8Eajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于java web开发中ajax一部请求使用的注意事项 在web开发当中，原生的ajax异步使用还是较少的，因为jQuery为我们提供了更好的封装：jQuery.ajax(url,[settings])。 通过http请求加载远程数据，可以使浏览器在不刷新页面的情况下来进行局部页面数据的改变，所以ajax还是很有那必要了解并学习一下的。 jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。 ajax回调函数 如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。 而一般日常使用的是处理成功后返回的信息，主要还是使用success 数据类型 可以处理的主要数据类型有xml、html、就送、jsonp、script、text，通过dataType选项还指定不同数据处理方式 。其中，text和xml类型返回的数据不会经过处理。数据仅仅简单的将XMLHttpRequest的responseText或responseHTML属性传递给success回调函数。 发送数据到服务器 默认情况下，Ajax请求使用GET方法。如果要使用POST方法，可以设定type参数值。 实例 加载并执行一个js文件 12345$.ajax(&#123; type: &quot;GET&quot;, url: &quot;test.js&quot;, dataType: &quot;script&quot;&#125;); 保存数据到服务器，成功时显示信息 12345678$.ajax(&#123; type: &quot;POST&quot;, url: &quot;some.php&quot;, data: &quot;name=John&amp;location=Boston&quot;, success: function(msg)&#123; alert( &quot;Data Saved: &quot; + msg ); &#125;&#125;); 装入一个html网页最新版 1234567$.ajax(&#123; url: &quot;test.html&quot;, cache: false, success: function(html)&#123; $(&quot;#results&quot;).append(html); &#125;&#125;); 拿json来说 而后台处理请求时，若使用的是SSM，只需添加jackson jar包，在Controller上添加@Responsebody，这样就会自动将返回数据封装为json对象，并在前端success函数中进行解析。 若是使用原生servlet处理请求，为更好的对数据进行封装，须引入json相关的jar包，将数据封装为JSONObject对象或JSONArray对象，设置response.setCharacterEncoding(“utf-8”)，调用 response.getWriter().write(jsonObject.toString())将数据返回到前端，后在success中进行解析。 高层方法$.get(url,[data],[fn],[type]) $.getJSON(url,[data],[fn]) $.post(url,[data],[fn],[type])]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Java web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射基础]]></title>
    <url>%2F2018%2F05%2F13%2FJava%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Java反射基础Java,一门完全面向对象语言，在Java的世界中处处皆是对象， 当然，一个class、一个method、一个field这些也都例外。 而反射(reflect)，不仅能动态加载类，还能让其获取自身的信息： Class类的使用：12345678910111213141516171819202122232425public class ClassDemo&#123; public static void main(String[] args) &#123; Test t1 = new Test(); Class c1 = Test.class; Class c2 = t1.getClass(); System.out.println(c1 == c2); // 证明类类型也是引用 Class c3 = null; try &#123; c3 = Class.forName(&quot;com.reflect.Test&quot;); // 动态加载Test类 &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(c2 == c3); &#125; &#125; class Test&#123;&#125; 打印结果为：true true 获取方法信息：123456789101112131415161718192021222324252627282930313233public class ClassUtil&#123; public static void printClassMeeeage(Object obj) &#123; // 获取类的信息 首先获得类的类类型 Class c = obj.getClass(); // 获取类的名称 System.out.println(&quot;类的名称：&quot; + c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethod()方法获取的是所有的public函数，包括父类继承而来 * */ Method[] ms = c.getMethods(); // c.getDeclaredMethod() for (int i = 0; i &lt; ms.length; i++) &#123; // 得到方法返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName() + &quot; &quot;); // 得到方法名称 System.out.print(ms[i].getName() + &quot;(&quot;); // 获取参数类型 参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + &quot;, &quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125;&#125; 获取成员变量信息：*成员变量也是对象 *java.lang.reflect.Field *Field封装了关于成员变量的操作 *getDeclaredField获取的是该类声明的所有的数据成员的信息 1234567891011121314public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; // 获取成员变量类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); // 获取成员变量的名称 String fieldName = field.getName(); System.out.println(fieldName + &quot; &quot; + typeName); &#125; &#125; 获取构造方法信息* 构造方法也是对象 * java.lang.reflect.Constructor * Constructor封装了关于构造方法的操作 * getConstructor获得该类声明额构造方法 12345678910111213141516public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName() + &quot;(&quot;); // 获取构造函数的参数列表 Class paramTypes[] = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java web中路径访问问题]]></title>
    <url>%2F2018%2F05%2F13%2FJava%20Web%E4%B8%AD%E8%B7%AF%E5%BE%84%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Java web中Servlet、jsp、html互相访问的路径问题 在java web学习过程中经常出现 404 not found这种找不到网页的错误，究其原因，还是访问路径不正确。 在web项目中，访问路径主要分为两类： 绝对路径 相对路径 在写过如此多的demo之后，为防止意外，我个人还是建议使用绝对路径。 一般URL格式都是 http://localhost:8080/myapp/*** String path = request.getContextPath(); 获取到的就是 /myapp 可以将其放入到request域中，然后在页面请求中添加 1request.setAttribute(&quot;APP_PATH&quot;,path); 调用时直接用EL表达式取出值：${APP_PATH}]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS表单校验实例]]></title>
    <url>%2F2018%2F05%2F13%2FJS%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[JS表单校验实例 表单也算是一个系统中必不可少的组建，当然，对于表单提交的数据必然的要进行一些验证。 而表单数据验证，一般来说是两道屏障。 前端校验 后端校验 而前端校验主要就是通过JS或者jQuery来操作了，下面给出一些前端数据校验实例： 12345678910111213141516171819202122232425262728293031/*是否带有小数*/function isDecimal(strValue ) &#123;var objRegExp= /^\d+\.\d+$/;return objRegExp.test(strValue);&#125;/*校验是否中文名称组成 */function ischina(str) &#123;var reg=/^[\u4E00-\u9FA5]&#123;2,4&#125;$/; /*定义验证表达式*/return reg.test(str); /*进行验证*/&#125;/*校验是否全由8位数字组成 */function isStudentNo(str) &#123;var reg=/^[0-9]&#123;8&#125;$/; /*定义验证表达式*/return reg.test(str); /*进行验证*/&#125;/*校验电话码格式 */function isTelCode(str) &#123;var reg= /^((0\d&#123;2,3&#125;-\d&#123;7,8&#125;)|(1[3584]\d&#123;9&#125;))$/;return reg.test(str);&#125;/*校验邮件地址是否合法 */function IsEmail(str) &#123;var reg=/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\.[a-zA-Z0-9_-])+/;return reg.test(str);&#125; 所谓校验主要还是通过正则表达式来匹配一系列字符，而对于正则表达式的理解还是处于 ‘ 知道有有这么个东西 ’ 的层面，虽然也看过一些关于正则表达式使用的一些语法，但在真正使用的时候还是感觉力不从心。关于正则，有时间还是要看一下的，日常多留心去使用，学会慢慢积累！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F10%2FHello%20World%2F</url>
    <content type="text"><![CDATA[Hello World引言Hi，很高兴今天正式搭建起一个要下定决心写点东西的小博客了。 没有什么原因，总感觉大学四年到头来留不下点什么东西吧！ 其实也没什么特别需要记录的东西，以后记录的东西都是给自己看的，所有有幸光临此地 的朋友也不要留下太多的骂声了！ 简单熟悉一下markdown基本语法吧： 1234567891011121314151617181920212223242526272829303132## 格式**粗体**、*斜体*、==高亮==、~~删除线~~、&lt;u&gt;下划线&lt;/u&gt;、我是^上标^、我是~下标~、[超链接](http://www.baidu.com)![图片](https://img3.doubanio.com/view/movie_poster_cover/lpst/public/p2411953504.jpg)## 无序列表- 无序列表1- 无序列表2## 有序列表1. 有序列表2. 有序列表## 任务列表- [ ] 看电影- [ ] 听音乐 ##代码`这是代码框`~~~这是代码块##分割线***上面是分割线***下面是分割线*** 显示效果如下： 格式粗体 斜体 ==高亮== 删除线 下划线 我是 ^上标^ 我是~下标~ 超链接 无序列表 无序列表1 无需列表2 有序列表 有序列表 有序列表 ##任务列表 看电影 听音乐 吃饭饭 代码public static void main(String[] args) { System.out.println(&quot;Hello World!&quot;); } 代码块1234int main()&#123; std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;&#125; 12345public class Main &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 分割线 上面是分割线 下面是分割线]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
</search>
